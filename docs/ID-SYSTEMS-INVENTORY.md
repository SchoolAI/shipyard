# ID Systems Inventory

> Comprehensive documentation of all identity systems used in shipyard.

## Overview

Shipyard uses multiple ID systems that serve different purposes. This document catalogs each system to prevent confusion and type mismatches.

---

## ID Systems Summary Table

| ID Type | Format | Generated By | Used For | Key Files |
|---------|--------|--------------|----------|-----------|
| **Plan ID** | `string` (nanoid, 21 chars) | Server (`hook-api.ts`) | Plan identification | `plan.ts`, `hook-api.ts` |
| **Session Token** | `string` (nanoid) | MCP tools | API authentication | `hook-api.ts` |
| **Session Token Hash** | `string` (SHA256) | Server | Stored in Y.Doc | `plan.ts` |
| **GitHub Username** | `string` | GitHub OAuth | User identity, ownership | `useGitHubAuth.ts` |
| **Owner ID** | `string` (GitHub username) | Server | Plan ownership | `yjs-helpers.ts` |
| **User ID** | `string` (GitHub username) | GitHub OAuth | Approval system | `yjs-helpers.ts` |
| **Awareness Client ID** | `number` | Yjs | Document sync | `useP2PPeers.ts` |
| **WebRTC Peer ID** | `string` (UUID v4) | y-webrtc | P2P transfers | `useMultiProviderSync.ts` |
| **Review Request ID** | `string` (nanoid) | MCP tools | Review cycle tracking | `plan.ts` |
| **Thread ID** | `string` | BlockNote | Comment threads | `thread.ts` |
| **Deliverable ID** | `string` | BlockNote | Task tracking | `plan.ts` |
| **Artifact ID** | `string` | Server | Proof-of-work | `plan.ts` |
| **Export ID** | `string` (UUID) | Browser | P2P transfer tracking | `ConversationTransferManager.ts` |

---

## Detailed ID Documentation

### 1. Plan ID

**What it identifies:** A single plan document

**Type:** `string` (nanoid, 21 characters)

**Where generated:** `apps/server/src/hook-api.ts` line 73
```typescript
const planId = nanoid();
```

**Where used:**
- URL path: `/plan/{planId}`
- Y.Doc document name
- IndexedDB persistence key
- WebRTC room name (prefixed with `shipyard-`)

**Flow:**
1. Claude Code hook calls `POST /api/hook/session`
2. Server generates `planId = nanoid()`
3. Server creates Y.Doc with this ID
4. URL returned to hook: `{webUrl}/plan/{planId}`

---

### 2. GitHub Username / User ID / Owner ID

**What it identifies:** A GitHub user

**Type:** `string` (GitHub username, e.g., "jacobpetterle")

**Where generated:** GitHub OAuth flow

**Where used:**
- `ownerId` in plan metadata (who created the plan)
- `approvedUsers[]` in plan metadata
- `rejectedUsers[]` in plan metadata
- `userId` in thread comments
- `user.id` in awareness state

**Flow:**
1. User authenticates via GitHub OAuth
2. Username stored in React context (`useGitHubAuth`)
3. Written to Y.Doc metadata as `ownerId` on plan creation
4. Broadcast via awareness protocol for peer identification

**Files:**
- `apps/web/src/hooks/useGitHubAuth.ts`
- `packages/schema/src/yjs-helpers.ts`
- `packages/schema/src/plan.ts`

---

### 3. Awareness Client ID

**What it identifies:** A Yjs document client (browser tab/instance)

**Type:** `number` (32-bit integer)

**Where generated:** Yjs automatically assigns on Y.Doc creation

**Where used:**
- Yjs awareness protocol
- Tracking connected peers
- Document sync

**Important:** This is **NOT** the same as WebRTC Peer ID!

**Access:**
```typescript
const awareness = rtcProvider.awareness;
const myClientId = awareness.clientID; // number
```

**Files:**
- `apps/web/src/hooks/useP2PPeers.ts`
- `apps/web/src/hooks/useMultiProviderSync.ts`

---

### 4. WebRTC Peer ID

**What it identifies:** A y-webrtc room participant

**Type:** `string` (UUID v4, e.g., "a1b2c3d4-e5f6-7890-abcd-ef1234567890")

**Where generated:** y-webrtc Room constructor (`random.uuidv4()`)

**Where used:**
- Key in `room.webrtcConns` Map
- P2P message routing
- ConversationTransferManager peer lookup

**Important:** This is **NOT** the same as Awareness Client ID!

**Access:**
```typescript
// Get own peerId
const webrtcPeerId = (rtcProvider as any).room?.peerId;

// Get all peer connections (keyed by remote peer's webrtcPeerId)
const room = (rtcProvider as any).room;
for (const [peerId, conn] of room.webrtcConns) {
  // peerId is a UUID string
}
```

**Files:**
- `apps/web/src/hooks/useConversationTransfer.ts`
- `apps/web/src/utils/ConversationTransferManager.ts`

---

### 5. Session ID (Agent Session)

**What it identifies:** A Claude Code / Devin / other agent session

**Type:** `string` (format varies by platform)

**Where generated:** Agent platform (e.g., Claude Code generates session IDs)

**Where used:**
- Tracking agent presence in plan
- Origin metadata for conversation export
- Presence heartbeat

**Files:**
- `packages/schema/src/hook-api.ts`
- `packages/schema/src/plan.ts` (origin metadata)

---

### 6. Review Request ID

**What it identifies:** A review request cycle

**Type:** `string` (nanoid)

**Where generated:** MCP `request_plan_review` tool

**Where used:**
- Preventing stale review decisions
- Ensuring approval matches current request

**Flow:**
1. Agent calls `request_plan_review`
2. Server generates `reviewRequestId = nanoid()`
3. Stored in Y.Doc metadata
4. When reviewer approves/denies, ID must match

**Files:**
- `packages/schema/src/plan.ts`
- `apps/server/src/tools/`

---

### 7. Export ID

**What it identifies:** A P2P conversation transfer

**Type:** `string` (UUID from `crypto.randomUUID()`)

**Where generated:** `ConversationTransferManager.sendConversation()`

**Where used:**
- Tracking multi-chunk transfers
- Cancellation support
- Progress tracking

**Files:**
- `apps/web/src/utils/ConversationTransferManager.ts`

---

## Critical Mismatch: Awareness Client ID vs WebRTC Peer ID

### The Bug (Fixed)

**Problem:** Code was passing `peerId` (awareness clientID, number) to `sendToPeer()` which expected the WebRTC peerId (UUID string).

```typescript
// WRONG - peerId is awareness clientID (number)
sendToPeer(peer.peerId, messages);

// CORRECT - webrtcPeerId is y-webrtc peer ID (UUID string)
sendToPeer(peer.webrtcPeerId, messages);
```

### Why They're Different

| Property | Awareness Client ID | WebRTC Peer ID |
|----------|---------------------|----------------|
| Type | `number` | `string` (UUID) |
| Generated by | Yjs | y-webrtc |
| Purpose | Document sync | P2P messaging |
| Uniqueness | Unique per Y.Doc instance | Unique per WebRTC room |
| Stability | Changes on page refresh | Changes on room rejoin |

### Solution

1. **Added `webrtcPeerId` to awareness state** - Each peer broadcasts their WebRTC peerId through the awareness protocol
2. **Updated `ConnectedPeer` interface** - Added `webrtcPeerId: string | undefined` field
3. **Updated `HandoffConversationDialog`** - Uses `peer.webrtcPeerId` for P2P transfers

---

## ID Flow Diagrams

### Plan Creation Flow

```
Claude Code Hook → Server API → Y.Doc
     │                │           │
     │                │           ├── planId (nanoid)
     │                │           ├── ownerId (GitHub username)
     │                │           └── sessionTokenHash (SHA256)
     │                │
     │                └── Returns: { planId, url }
     │
     └── Opens browser at url
```

### Peer Connection Flow

```
Browser A                    Browser B
    │                            │
    ├── awareness.clientID       ├── awareness.clientID
    │   (number)                 │   (number)
    │                            │
    ├── room.peerId              ├── room.peerId
    │   (UUID string)            │   (UUID string)
    │                            │
    └── awareness.setLocalState({
          planStatus: {
            user: { id: githubUsername },
            webrtcPeerId: room.peerId  ← Links the two IDs
          }
        })
```

### P2P Transfer Flow

```
Sender                              Receiver
   │                                    │
   ├── useP2PPeers() returns:           │
   │   [{ peerId: 123, webrtcPeerId: "abc-def" }]
   │                                    │
   ├── sendToPeer("abc-def", messages)  │
   │                                    │
   └── ConversationTransferManager      │
       .peers.get("abc-def")            │
       └── simple-peer.send()  ─────────→ Receives data
```

---

## Type Aliases (Recommended)

To prevent future mismatches, consider adding branded types:

```typescript
// packages/schema/src/ids.ts

/** Yjs awareness client ID (number) */
export type AwarenessClientId = number & { readonly __brand: 'AwarenessClientId' };

/** y-webrtc peer ID (UUID string) */
export type WebRTCPeerId = string & { readonly __brand: 'WebRTCPeerId' };

/** Plan ID (nanoid string) */
export type PlanId = string & { readonly __brand: 'PlanId' };

/** GitHub username */
export type GitHubUsername = string & { readonly __brand: 'GitHubUsername' };
```

This would make the type system catch mismatches at compile time.

---

## Checklist for Adding New ID Types

When adding a new ID type:

1. [ ] Document in this file
2. [ ] Add to summary table
3. [ ] Create type alias if appropriate
4. [ ] Document generation location
5. [ ] Document all usage locations
6. [ ] Verify no type mismatches with existing IDs

---

*Last updated: 2026-01-13*
