# Milestone 6: P2P Remote Collaboration

**Status**: Not Started
**Goal**: Multiple remote reviewers can collaborate via WebRTC

---

## Overview

Add peer-to-peer sync so that:
1. Remote reviewers can join via shared URL
2. All reviewers see each other's annotations in real-time
3. Works without central server (after initial sync)

---

## Deliverables

### 6a: WebRTC Adapter

- [ ] Add `@loro-extended/adapter-webrtc` to browser
- [ ] Configure STUN servers (Google's free servers)
- [ ] Configure signaling server (`wss://signaling.yjs.dev`)

### 6b: Multi-Adapter Setup

Browser now has THREE adapters:
1. WebSocket → MCP server (localhost)
2. IndexedDB → local persistence
3. WebRTC → remote peers

```typescript
const adapters = [
  new WsClientNetworkAdapter({ url: wsUrl }),
  new IndexedDBStorageAdapter(),
  new WebRTCNetworkAdapter({
    signaling: ['wss://signaling.yjs.dev'],
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
  }),
];
```

### 6c: Peer Presence

- [ ] Show who's currently viewing the plan
- [ ] Display peer cursors/focus (optional)
- [ ] "X reviewers online" indicator

### 6d: Offline/Online Handling

- [ ] Graceful degradation when peers offline
- [ ] Sync catchup when peer comes online
- [ ] Handle MCP server going offline (P2P continues)

---

## Demo Checkpoint

**Scenario**: Multiple reviewers collaborate remotely

```
1. Agent creates plan, opens in browser A
2. Agent shares URL with remote reviewer
3. Reviewer opens in browser B (different network)
4. Both browsers show each other as "online"
5. Reviewer B adds annotation
6. Browser A sees it immediately (via WebRTC, not via MCP server)
7. Agent (via MCP) also sees it (via WebSocket to browser A)
```

---

## Success Criteria

1. Two browsers on different networks can sync
2. Annotations appear in < 1 second
3. Works even if MCP server is stopped (P2P direct)
4. Presence shows who's online

---

## Technical Notes

### WebRTC Configuration

```typescript
import { WebRTCNetworkAdapter } from '@loro-extended/adapter-webrtc';

const webrtcAdapter = new WebRTCNetworkAdapter({
  // Multiple signaling servers for redundancy
  signaling: [
    'wss://signaling.yjs.dev',
    'wss://y-webrtc-signaling-us.herokuapp.com',
    'wss://y-webrtc-signaling-eu.herokuapp.com',
  ],

  // STUN servers for NAT traversal
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
  ],

  // Room ID based on plan ID
  room: `peer-plan-${planId}`,
});
```

### Presence with Ephemeral State

```typescript
const PresenceSchema = Shape.plain.struct({
  name: Shape.plain.string(),
  cursor: Shape.plain.struct({
    stepId: Shape.plain.string().nullable(),
  }).nullable(),
});

const handle = useHandle(planId, LiveStateSchema, {
  presence: PresenceSchema,
});

// Set your presence
handle.presence.setSelf({
  name: userName,
  cursor: { stepId: focusedStepId },
});

// Read others' presence
const { peers } = useEphemeral(handle.presence);
// peers is Map<peerId, PresenceData>
```

### Sync Topology

```
┌─────────────┐     WebSocket      ┌─────────────┐
│ MCP Server  │◄──────────────────►│ Browser A   │
└─────────────┘                    └──────┬──────┘
                                          │
                                    WebRTC P2P
                                          │
                                   ┌──────┴──────┐
                                   │ Browser B   │
                                   │ (remote)    │
                                   └─────────────┘
```

If MCP server goes offline:
- Browser A ↔ Browser B still sync via WebRTC
- Both have IndexedDB persistence
- When MCP comes back, Browser A syncs it

---

## Dependencies

- Milestone 4 (Review Flow) - need something to collaborate on

## Blocks

- Nothing (this is the final feature milestone)

---

*Created: 2026-01-02*
