{"version":3,"file":"index.mjs","names":["t","assertNever","t"],"sources":["../src/conversation-export.ts","../src/deliverable-formatter.ts","../src/deliverable-parser.ts","../src/github-validation.ts","../src/ids.ts","../src/invite-token.ts","../src/p2p-messages.ts","../src/plan-index.ts","../src/plan-index-helpers.ts","../src/routes.ts","../src/thread-formatter.ts","../src/trpc/schemas.ts","../src/trpc/trpc.ts","../src/trpc/routers/conversation.ts","../src/trpc/routers/hook.ts","../src/trpc/routers/plan.ts","../src/trpc/routers/subscription.ts","../src/trpc/index.ts","../src/user-helpers.ts"],"sourcesContent":["/**\n * Conversation export types and converters for A2A protocol.\n *\n * This module provides:\n * 1. A2A Message schema definitions (following A2A spec)\n * 2. Claude Code JSONL transcript parser\n * 3. Converter from Claude Code format to A2A format\n *\n * A2A (Agent-to-Agent) is an emerging protocol for interoperability\n * between AI agent platforms. See: https://a2a-protocol.org/latest/specification/\n *\n * @see Issue #41 - Context Teleportation\n */\n\nimport { z } from 'zod';\n\n/**\n * A2A Text Part - plain text content\n */\nexport const A2ATextPartSchema = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n});\nexport type A2ATextPart = z.infer<typeof A2ATextPartSchema>;\n\n/**\n * A2A Data Part - structured data (JSON)\n * Used for tool calls, results, and other structured content\n */\nexport const A2ADataPartSchema = z.object({\n  type: z.literal('data'),\n  data: z.unknown(),\n});\nexport type A2ADataPart = z.infer<typeof A2ADataPartSchema>;\n\n/**\n * A2A File Part - file reference\n * Used for file attachments, images, etc.\n */\nexport const A2AFilePartSchema = z.object({\n  type: z.literal('file'),\n  uri: z.string(),\n  mediaType: z.string().optional(),\n  name: z.string().optional(),\n});\nexport type A2AFilePart = z.infer<typeof A2AFilePartSchema>;\n\n/**\n * A2A Part schema - validates any of the three part types\n * Uses a custom approach to avoid Zod v4 issues with union arrays\n */\nexport const A2APartSchema = z\n  .object({\n    type: z.enum(['text', 'data', 'file']),\n  })\n  .passthrough()\n  .superRefine((val, ctx) => {\n    if (val.type === 'text') {\n      if (typeof (val as { text?: unknown }).text !== 'string') {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'text part must have a string text field',\n        });\n      }\n    } else if (val.type === 'data') {\n      if (!('data' in val)) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'data part must have a data field',\n        });\n      }\n    } else if (val.type === 'file') {\n      if (typeof (val as { uri?: unknown }).uri !== 'string') {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'file part must have a string uri field',\n        });\n      }\n    }\n  });\nexport type A2APart = A2ATextPart | A2ADataPart | A2AFilePart;\n\n/**\n * A2A Message - the core message type\n * Represents a single message in a conversation\n *\n * Uses z.any() for parts array to avoid Zod v4 issues with complex\n * union types in arrays. Parts are validated via superRefine.\n */\n/**\n * Validates A2A parts array manually.\n * Returns true if all parts are valid.\n */\nfunction isValidA2APart(part: unknown): boolean {\n  if (!part || typeof part !== 'object') return false;\n  const p = part as Record<string, unknown>;\n  const t = p.type;\n  if (t === 'text') {\n    return typeof p.text === 'string';\n  } else if (t === 'data') {\n    return 'data' in p;\n  } else if (t === 'file') {\n    return typeof p.uri === 'string';\n  }\n  return false;\n}\n\nfunction isValidA2AParts(parts: unknown): parts is A2APart[] {\n  if (!Array.isArray(parts)) return false;\n  return parts.every(isValidA2APart);\n}\n\n/**\n * A2A Message schema - validates the full message structure.\n * Uses a custom schema to work around Zod v4 issues with complex union arrays.\n */\nexport const A2AMessageSchema = z\n  .object({\n    messageId: z.string(),\n    role: z.enum(['user', 'agent']),\n    contextId: z.string().optional(),\n    taskId: z.string().optional(),\n    referenceTaskIds: z.array(z.string()).optional(),\n    metadata: z.record(z.string(), z.unknown()).optional(),\n    extensions: z.array(z.string()).optional(),\n  })\n  .passthrough()\n  .refine(\n    (val) => {\n      const parts = (val as Record<string, unknown>).parts;\n      return isValidA2AParts(parts);\n    },\n    {\n      message: 'Invalid parts array - each part must have valid type and required fields',\n      path: ['parts'],\n    }\n  )\n  .transform((val) => ({\n    ...val,\n    parts: (val as unknown as { parts: A2APart[] }).parts,\n  }));\nexport type A2AMessage = {\n  messageId: string;\n  role: 'user' | 'agent';\n  parts: A2APart[];\n  contextId?: string;\n  taskId?: string;\n  referenceTaskIds?: string[];\n  metadata?: Record<string, unknown>;\n  extensions?: string[];\n};\n\n/**\n * Metadata about a conversation export\n */\nexport const ConversationExportMetaSchema = z.object({\n  exportId: z.string(),\n  sourcePlatform: z.string(),\n  sourceSessionId: z.string(),\n  planId: z.string(),\n  exportedAt: z.number(),\n  messageCount: z.number(),\n  compressedBytes: z.number(),\n  uncompressedBytes: z.number(),\n});\nexport type ConversationExportMeta = z.infer<typeof ConversationExportMetaSchema>;\n\n/**\n * Claude Code text content block\n */\nconst ClaudeCodeTextBlockSchema = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n});\ntype ClaudeCodeTextBlock = z.infer<typeof ClaudeCodeTextBlockSchema>;\n\n/**\n * Claude Code tool use content block\n */\nconst ClaudeCodeToolUseBlockSchema = z.object({\n  type: z.literal('tool_use'),\n  id: z.string(),\n  name: z.string(),\n  input: z.record(z.string(), z.unknown()),\n});\ntype ClaudeCodeToolUseBlock = z.infer<typeof ClaudeCodeToolUseBlockSchema>;\n\n/**\n * Claude Code tool result content block\n */\nconst ClaudeCodeToolResultBlockSchema = z.object({\n  type: z.literal('tool_result'),\n  tool_use_id: z.string(),\n  content: z.unknown(),\n  is_error: z.boolean().optional(),\n});\ntype ClaudeCodeToolResultBlock = z.infer<typeof ClaudeCodeToolResultBlockSchema>;\n\n/**\n * Claude Code content block schema\n * Uses a custom approach to avoid Zod v4 issues with union arrays\n */\nconst ClaudeCodeContentBlockSchema = z\n  .object({\n    type: z.enum(['text', 'tool_use', 'tool_result']),\n  })\n  .passthrough()\n  .superRefine((val, ctx) => {\n    const typedVal = val as Record<string, unknown>;\n    if (val.type === 'text') {\n      if (typeof typedVal.text !== 'string') {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'text block must have a string text field',\n        });\n      }\n    } else if (val.type === 'tool_use') {\n      if (typeof typedVal.id !== 'string') {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'tool_use block must have a string id field',\n        });\n      }\n      if (typeof typedVal.name !== 'string') {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'tool_use block must have a string name field',\n        });\n      }\n      if (typeof typedVal.input !== 'object' || typedVal.input === null) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'tool_use block must have an object input field',\n        });\n      }\n    } else if (val.type === 'tool_result') {\n      if (typeof typedVal.tool_use_id !== 'string') {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'tool_result block must have a string tool_use_id field',\n        });\n      }\n    }\n  });\ntype ClaudeCodeContentBlock =\n  | ClaudeCodeTextBlock\n  | ClaudeCodeToolUseBlock\n  | ClaudeCodeToolResultBlock;\n\n/**\n * Claude Code token usage\n */\nconst ClaudeCodeUsageSchema = z.object({\n  input_tokens: z.number(),\n  output_tokens: z.number(),\n  cache_creation_input_tokens: z.number().optional(),\n  cache_read_input_tokens: z.number().optional(),\n});\n\n/**\n * Claude Code message inner structure\n */\nconst ClaudeCodeMessageInnerSchema = z.object({\n  role: z.string(),\n  content: z.array(ClaudeCodeContentBlockSchema),\n  id: z.string().optional(),\n  model: z.string().optional(),\n  usage: ClaudeCodeUsageSchema.optional(),\n});\n\n/**\n * Claude Code JSONL message schema\n * This is the full structure of each line in the session.jsonl file\n */\nexport const ClaudeCodeMessageSchema = z.object({\n  sessionId: z.string(),\n  type: z.enum(['user', 'assistant', 'summary']),\n  message: ClaudeCodeMessageInnerSchema,\n  uuid: z.string(),\n  timestamp: z.string(),\n  parentUuid: z.string().optional(),\n  costUSD: z.number().optional(),\n  durationMs: z.number().optional(),\n});\nexport type ClaudeCodeMessage = z.infer<typeof ClaudeCodeMessageSchema>;\n\n/**\n * Result of parsing a transcript - includes both successful and failed parses\n */\nexport interface ParseTranscriptResult {\n  messages: ClaudeCodeMessage[];\n  errors: Array<{ line: number; error: string }>;\n}\n\n/**\n * Parses a Claude Code JSONL transcript from a string.\n *\n * Each line in the JSONL file is a separate JSON object representing\n * a message in the conversation. Malformed lines are captured in errors\n * array rather than throwing.\n *\n * @param content - Raw JSONL string content\n * @returns Parsed messages and any parsing errors\n */\nexport function parseClaudeCodeTranscriptString(content: string): ParseTranscriptResult {\n  const lines = content.split('\\n').filter((line) => line.trim());\n  const messages: ClaudeCodeMessage[] = [];\n  const errors: Array<{ line: number; error: string }> = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (!line) continue;\n\n    try {\n      const parsed: unknown = JSON.parse(line);\n      const result = ClaudeCodeMessageSchema.safeParse(parsed);\n\n      if (result.success) {\n        messages.push(result.data);\n      } else {\n        errors.push({\n          line: i + 1,\n          error: `Validation failed: ${result.error.message}`,\n        });\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      errors.push({\n        line: i + 1,\n        error: `JSON parse error: ${errorMessage}`,\n      });\n    }\n  }\n\n  return { messages, errors };\n}\n\n/**\n * Type guard helper for exhaustive checking in switch statements\n */\nfunction assertNever(x: never): never {\n  throw new Error(`Unhandled case: ${JSON.stringify(x)}`);\n}\n\n/**\n * Converts a single Claude Code content block to A2A parts.\n *\n * @param block - Claude Code content block\n * @returns Array of A2A parts (may return multiple for complex blocks)\n */\nfunction convertContentBlock(block: ClaudeCodeContentBlock): A2APart[] {\n  switch (block.type) {\n    case 'text':\n      return [\n        {\n          type: 'text',\n          text: block.text,\n        },\n      ];\n\n    case 'tool_use':\n      return [\n        {\n          type: 'data',\n          data: {\n            toolUse: {\n              name: block.name,\n              id: block.id,\n              input: block.input,\n            },\n          },\n        },\n      ];\n\n    case 'tool_result':\n      return [\n        {\n          type: 'data',\n          data: {\n            toolResult: {\n              toolUseId: block.tool_use_id,\n              content: block.content,\n              isError: block.is_error ?? false,\n            },\n          },\n        },\n      ];\n\n    default:\n      return assertNever(block);\n  }\n}\n\n/**\n * Converts a single Claude Code message to A2A format.\n *\n * @param msg - Claude Code message\n * @param contextId - Context ID to associate with the message\n * @returns A2A message\n */\nfunction convertMessage(msg: ClaudeCodeMessage, contextId: string): A2AMessage {\n  const role = msg.message.role === 'user' ? 'user' : 'agent';\n\n  const parts: A2APart[] = msg.message.content.flatMap((block) =>\n    convertContentBlock(block as ClaudeCodeContentBlock)\n  );\n\n  return {\n    messageId: msg.uuid,\n    role,\n    parts,\n    contextId,\n    metadata: {\n      timestamp: msg.timestamp,\n      platform: 'claude-code',\n      parentMessageId: msg.parentUuid,\n      model: msg.message.model,\n      usage: msg.message.usage,\n      costUSD: msg.costUSD,\n      durationMs: msg.durationMs,\n    },\n  };\n}\n\n/**\n * Converts an array of Claude Code messages to A2A format.\n *\n * Filters out 'summary' type messages as they are internal to Claude Code\n * and not part of the actual conversation.\n *\n * @param messages - Array of Claude Code messages\n * @param contextId - Context ID to associate with all messages (typically the plan ID)\n * @returns Array of A2A messages\n */\nexport function claudeCodeToA2A(messages: ClaudeCodeMessage[], contextId: string): A2AMessage[] {\n  return messages\n    .filter((msg) => msg.type !== 'summary')\n    .map((msg) => convertMessage(msg, contextId));\n}\n\n/**\n * Validates an array of A2A messages.\n * Useful for validating imported conversations.\n *\n * @param messages - Array of potential A2A messages\n * @returns Validation result with valid messages and errors\n */\nexport function validateA2AMessages(messages: unknown[]): {\n  valid: A2AMessage[];\n  errors: Array<{ index: number; error: string }>;\n} {\n  const valid: A2AMessage[] = [];\n  const errors: Array<{ index: number; error: string }> = [];\n\n  for (let i = 0; i < messages.length; i++) {\n    const result = A2AMessageSchema.safeParse(messages[i]);\n    if (result.success) {\n      valid.push(result.data);\n    } else {\n      errors.push({\n        index: i,\n        error: result.error.message,\n      });\n    }\n  }\n\n  return { valid, errors };\n}\n\n/**\n * Get the first text part from a message's parts.\n */\nfunction getFirstTextPart(parts: A2APart[]): A2ATextPart | undefined {\n  const textParts = parts.filter((p): p is A2ATextPart => p.type === 'text');\n  return textParts[0];\n}\n\n/**\n * Extract title from the first user message (truncated to 50 chars).\n */\nfunction extractTitleFromMessage(msg: A2AMessage | undefined): string {\n  if (!msg) return 'Imported Conversation';\n  const firstPart = getFirstTextPart(msg.parts);\n  if (!firstPart) return 'Imported Conversation';\n  const text = firstPart.text;\n  return text.length > 50 ? `${text.slice(0, 50)}...` : text;\n}\n\n/**\n * Check if a data part contains tool use or result.\n */\nfunction isToolDataPart(part: A2ADataPart): boolean {\n  const data = part.data;\n  return Boolean(data && typeof data === 'object' && ('toolUse' in data || 'toolResult' in data));\n}\n\n/**\n * Count tool interactions in a message's parts.\n */\nfunction countToolInteractions(parts: A2APart[]): number {\n  const dataParts = parts.filter((p): p is A2ADataPart => p.type === 'data');\n  return dataParts.filter(isToolDataPart).length;\n}\n\n/**\n * Create a summary line for a single message.\n */\nfunction summarizeMessage(msg: A2AMessage): string | undefined {\n  const prefix = msg.role === 'user' ? 'User' : 'Agent';\n  const firstTextPart = getFirstTextPart(msg.parts);\n\n  if (firstTextPart) {\n    const preview = firstTextPart.text.slice(0, 100);\n    const truncated = firstTextPart.text.length > 100 ? '...' : '';\n    return `${prefix}: ${preview}${truncated}`;\n  }\n\n  const toolCount = countToolInteractions(msg.parts);\n  if (toolCount > 0) {\n    return `${prefix}: [${toolCount} tool interaction(s)]`;\n  }\n\n  return undefined;\n}\n\n/**\n * Extracts a brief summary from A2A messages for display purposes.\n * Useful when creating a plan from imported conversation.\n *\n * @param messages - Array of A2A messages\n * @param maxMessages - Maximum number of messages to include in summary (default: 3)\n * @returns Object with title (first user message) and text (summary of exchange)\n */\nexport function summarizeA2AConversation(\n  messages: A2AMessage[],\n  maxMessages = 3\n): { title: string; text: string } {\n  const firstUserMessage = messages.find((m) => m.role === 'user');\n  const title = extractTitleFromMessage(firstUserMessage);\n\n  const messagesToSummarize = messages.slice(0, maxMessages);\n  const summaryLines = messagesToSummarize.map(summarizeMessage).filter(Boolean) as string[];\n\n  if (messages.length > maxMessages) {\n    summaryLines.push(`... and ${messages.length - maxMessages} more messages`);\n  }\n\n  return {\n    title,\n    text: summaryLines.join('\\n'),\n  };\n}\n\n/**\n * Type guard for checking if a data part contains tool use info.\n */\ninterface ToolUseData {\n  toolUse: {\n    name: string;\n    id: string;\n    input: Record<string, unknown>;\n  };\n}\n\n/**\n * Type guard for checking if a data part contains tool result info.\n */\ninterface ToolResultData {\n  toolResult: {\n    toolUseId: string;\n    content: unknown;\n    isError?: boolean;\n  };\n}\n\nfunction isToolUseData(data: unknown): data is ToolUseData {\n  if (!data || typeof data !== 'object') return false;\n  const d = data as Record<string, unknown>;\n  if (!d.toolUse || typeof d.toolUse !== 'object') return false;\n  const toolUse = d.toolUse as Record<string, unknown>;\n  return (\n    typeof toolUse.name === 'string' &&\n    typeof toolUse.id === 'string' &&\n    typeof toolUse.input === 'object'\n  );\n}\n\nfunction isToolResultData(data: unknown): data is ToolResultData {\n  if (!data || typeof data !== 'object') return false;\n  const d = data as Record<string, unknown>;\n  if (!d.toolResult || typeof d.toolResult !== 'object') return false;\n  const toolResult = d.toolResult as Record<string, unknown>;\n  return typeof toolResult.toolUseId === 'string';\n}\n\n/**\n * Converts a single A2A part to Claude Code content block(s).\n *\n * @param part - A2A part to convert\n * @returns Array of Claude Code content blocks\n */\nfunction convertA2APartToContentBlock(part: A2APart): ClaudeCodeContentBlock[] {\n  switch (part.type) {\n    case 'text':\n      return [\n        {\n          type: 'text',\n          text: part.text,\n        },\n      ];\n\n    case 'data': {\n      const data = part.data;\n\n      if (isToolUseData(data)) {\n        return [\n          {\n            type: 'tool_use',\n            id: data.toolUse.id,\n            name: data.toolUse.name,\n            input: data.toolUse.input as Record<string, unknown>,\n          },\n        ];\n      }\n\n      if (isToolResultData(data)) {\n        return [\n          {\n            type: 'tool_result',\n            tool_use_id: data.toolResult.toolUseId,\n            content: data.toolResult.content,\n            is_error: data.toolResult.isError,\n          },\n        ];\n      }\n\n      return [\n        {\n          type: 'text',\n          text: `[Data: ${JSON.stringify(data)}]`,\n        },\n      ];\n    }\n\n    case 'file':\n      return [\n        {\n          type: 'text',\n          text: `[File: ${part.name ?? part.uri}${part.mediaType ? ` (${part.mediaType})` : ''}]`,\n        },\n      ];\n\n    default:\n      return assertNever(part as never);\n  }\n}\n\n/**\n * Converts an A2A message to Claude Code format.\n *\n * @param msg - A2A message to convert\n * @param sessionId - Session ID to use for the Claude Code message\n * @param parentUuid - Optional parent message UUID\n * @returns Claude Code message\n */\nfunction convertA2AToClaudeCodeMessage(\n  msg: A2AMessage,\n  sessionId: string,\n  parentUuid?: string\n): ClaudeCodeMessage {\n  const role = msg.role === 'user' ? 'user' : 'assistant';\n  const type = msg.role === 'user' ? 'user' : 'assistant';\n\n  const content = msg.parts.flatMap(convertA2APartToContentBlock);\n\n  const metadata = msg.metadata || {};\n  const timestamp =\n    typeof metadata.timestamp === 'string' ? metadata.timestamp : new Date().toISOString();\n  const model = typeof metadata.model === 'string' ? metadata.model : undefined;\n  const usage = metadata.usage as\n    | {\n        input_tokens: number;\n        output_tokens: number;\n        cache_creation_input_tokens?: number;\n        cache_read_input_tokens?: number;\n      }\n    | undefined;\n  const costUSD = typeof metadata.costUSD === 'number' ? metadata.costUSD : undefined;\n  const durationMs = typeof metadata.durationMs === 'number' ? metadata.durationMs : undefined;\n\n  const claudeMsg: ClaudeCodeMessage = {\n    sessionId,\n    type,\n    message: {\n      role,\n      content,\n      ...(model && { model }),\n      ...(usage && { usage }),\n    },\n    uuid: msg.messageId,\n    timestamp,\n    ...(parentUuid && { parentUuid }),\n    ...(costUSD !== undefined && { costUSD }),\n    ...(durationMs !== undefined && { durationMs }),\n  };\n\n  return claudeMsg;\n}\n\n/**\n * Converts an array of A2A messages to Claude Code format.\n *\n * This is the inverse of claudeCodeToA2A(). It converts A2A messages\n * back to the Claude Code JSONL format for import into Claude Code sessions.\n *\n * @param messages - Array of A2A messages to convert\n * @param sessionId - Optional session ID (generates new one if not provided)\n * @returns Array of Claude Code messages\n */\nexport function a2aToClaudeCode(messages: A2AMessage[], sessionId?: string): ClaudeCodeMessage[] {\n  const resolvedSessionId = sessionId ?? crypto.randomUUID();\n\n  let parentUuid: string | undefined;\n\n  return messages.map((msg) => {\n    const claudeMsg = convertA2AToClaudeCodeMessage(msg, resolvedSessionId, parentUuid);\n    parentUuid = claudeMsg.uuid;\n    return claudeMsg;\n  });\n}\n\n/**\n * Formats an array of Claude Code messages as JSONL string.\n *\n * Claude Code session files are JSONL (JSON Lines) format where each\n * line is a complete JSON object representing one message.\n *\n * @param messages - Array of Claude Code messages\n * @returns JSONL formatted string\n */\nexport function formatAsClaudeCodeJSONL(messages: ClaudeCodeMessage[]): string {\n  return messages.map((msg) => JSON.stringify(msg)).join('\\n');\n}\n","/**\n * Shared deliverable formatting for LLM-friendly output.\n * Used by both MCP server (read_plan) and hook (ExitPlanMode denial).\n */\n\nimport type { Deliverable } from './plan.js';\n\n/**\n * Format deliverables list for LLM consumption.\n * Matches the format used in read_plan tool.\n */\nexport function formatDeliverablesForLLM(deliverables: Deliverable[]): string {\n  if (deliverables.length === 0) {\n    return '';\n  }\n\n  let output = '## Deliverables\\n\\n';\n  output += 'Available deliverable IDs for artifact linking:\\n\\n';\n\n  for (const deliverable of deliverables) {\n    const checkbox = deliverable.linkedArtifactId ? '[x]' : '[ ]';\n    const linkedInfo = deliverable.linkedArtifactId\n      ? ` (linked to artifact: ${deliverable.linkedArtifactId})`\n      : '';\n    output += `- ${checkbox} ${deliverable.text} {id=\"${deliverable.id}\"}${linkedInfo}\\n`;\n  }\n\n  return output;\n}\n","import type { Deliverable } from './plan.js';\n\n/**\n * Marker used to identify deliverables in BlockNote content.\n * Example: \"- [ ] Screenshot of login page {#deliverable}\"\n */\nexport const DELIVERABLE_MARKER = '{#deliverable}';\n\n/**\n * BlockNote block structure (simplified).\n * We only care about checkListItem blocks with {#deliverable} marker.\n * This is a minimal interface that matches BlockNote's actual Block type.\n */\ninterface Block {\n  id: string;\n  type: string;\n  content?: Array<{ type: string; text: string; styles?: Record<string, unknown> }> | unknown;\n  children?: Block[] | unknown;\n}\n\n/**\n * Extracts deliverables from BlockNote blocks.\n * Looks for checkListItem blocks with {#deliverable} marker in the text.\n *\n * Example:\n * - [ ] Screenshot of login page {#deliverable}\n * - [ ] Regular task (not a deliverable)\n *\n * @param blocks - BlockNote blocks array\n * @returns Array of deliverables extracted from marked checkboxes\n */\nexport function extractDeliverables(blocks: Block[]): Deliverable[] {\n  const deliverables: Deliverable[] = [];\n\n  function processBlock(block: Block): void {\n    const text = extractTextFromBlock(block);\n\n    if (text.includes(DELIVERABLE_MARKER)) {\n      const markerRegex = new RegExp(\n        `\\\\s*${DELIVERABLE_MARKER.replace(/[{}#]/g, '\\\\$&')}\\\\s*`,\n        'g'\n      );\n      const cleanText = text.replace(markerRegex, '').trim();\n\n      deliverables.push({\n        id: block.id,\n        text: cleanText,\n      });\n    }\n\n    if (block.children && Array.isArray(block.children)) {\n      for (const child of block.children) {\n        processBlock(child as Block);\n      }\n    }\n  }\n\n  for (const block of blocks) {\n    processBlock(block);\n  }\n\n  return deliverables;\n}\n\n/**\n * Extracts plain text from a BlockNote block's content array.\n */\nfunction extractTextFromBlock(block: Block): string {\n  if (!block.content || !Array.isArray(block.content) || block.content.length === 0) {\n    return '';\n  }\n\n  return block.content\n    .map((item: { text?: string }) => item.text || '')\n    .join('')\n    .trim();\n}\n","import { z } from 'zod';\n\n/**\n * Validation schema for GitHub Pull Request API responses.\n *\n * Ensures GitHub API responses contain required fields before creating LinkedPR objects.\n * Prevents runtime errors from malformed or incomplete API responses.\n *\n * NOTE: This schema ONLY validates fields we actively use for LinkedPR creation.\n * GitHub's full PR API response contains 50+ additional fields (created_at, body, user, etc.)\n * that we intentionally exclude because we don't need them. This is a validation layer,\n * not a complete API mirror.\n *\n * Validated fields:\n * - number: PR number for linking\n * - html_url: GitHub URL for display\n * - title: PR title for display\n * - state: 'open' or 'closed' (for status mapping)\n * - draft: Draft status (required by GitHub API, no default needed)\n * - merged: Merged status (required by GitHub API, no default needed)\n * - head.ref: Branch name\n *\n * PERFORMANCE NOTE: Validation overhead is ~0.1-0.5ms per Zod parse, which is negligible\n * compared to CRDT sync operations (~5-50ms) and network I/O. The safety guarantees\n * from runtime validation far outweigh the minimal performance cost.\n *\n * @see https://docs.github.com/en/rest/pulls/pulls#get-a-pull-request\n */\nexport const GitHubPRResponseSchema = z.object({\n  number: z.number(),\n  html_url: z.string().url(),\n  title: z.string(),\n  state: z.enum(['open', 'closed']),\n  draft: z.boolean(),\n  merged: z.boolean(),\n  head: z.object({\n    ref: z.string(),\n  }),\n});\n\nexport type GitHubPRResponse = z.infer<typeof GitHubPRResponseSchema>;\n","/**\n * Branded type aliases for ID systems.\n *\n * These types use TypeScript's branded types pattern to prevent\n * accidental misuse of IDs across different systems.\n *\n * @see docs/ID-SYSTEMS-INVENTORY.md for complete documentation\n */\n\n/**\n * Yjs awareness client ID.\n * A 32-bit integer assigned by Yjs when a Y.Doc is created.\n * Used for document synchronization and tracking connected clients.\n *\n * NOT the same as WebRTCPeerId!\n */\nexport type AwarenessClientId = number & { readonly __brand: 'AwarenessClientId' };\n\n/**\n * y-webrtc peer ID.\n * A UUID v4 string generated by y-webrtc for each room participant.\n * Used as the key in room.webrtcConns Map.\n *\n * NOT the same as AwarenessClientId!\n */\nexport type WebRTCPeerId = string & { readonly __brand: 'WebRTCPeerId' };\n\n/**\n * Plan ID.\n * A nanoid (21 character) string generated when a plan is created.\n * Used in URLs, Y.Doc document names, and IndexedDB keys.\n */\nexport type PlanId = string & { readonly __brand: 'PlanId' };\n\n/**\n * GitHub username.\n * Used for user identity, plan ownership, and approval system.\n */\nexport type GitHubUsername = string & { readonly __brand: 'GitHubUsername' };\n\n/**\n * Session token.\n * A nanoid string used for authenticating MCP API requests.\n * The hash of this token is stored in the Y.Doc.\n */\nexport type SessionToken = string & { readonly __brand: 'SessionToken' };\n\n/**\n * Review request ID.\n * A nanoid string generated when a review is requested.\n * Used to prevent stale review decisions.\n */\nexport type ReviewRequestId = string & { readonly __brand: 'ReviewRequestId' };\n\n/**\n * Export ID.\n * A UUID string generated for P2P conversation transfers.\n * Used to track multi-chunk transfers.\n */\nexport type ExportId = string & { readonly __brand: 'ExportId' };\n\n/**\n * Creates a PlanId from a string.\n * Use this when you know the string is a valid plan ID.\n */\nexport function asPlanId(id: string): PlanId {\n  return id as PlanId;\n}\n\n/**\n * Creates an AwarenessClientId from a number.\n * Use this when you know the number is from awareness.clientID.\n */\nexport function asAwarenessClientId(id: number): AwarenessClientId {\n  return id as AwarenessClientId;\n}\n\n/**\n * Creates a WebRTCPeerId from a string.\n * Use this when you know the string is from room.peerId.\n */\nexport function asWebRTCPeerId(id: string): WebRTCPeerId {\n  return id as WebRTCPeerId;\n}\n\n/**\n * Creates a GitHubUsername from a string.\n * Use this when you know the string is a GitHub username.\n */\nexport function asGitHubUsername(username: string): GitHubUsername {\n  return username as GitHubUsername;\n}\n","import { z } from 'zod';\n\n/**\n * Invite token for time-limited P2P room access.\n * Stored server-side only (not in CRDT) to prevent client manipulation.\n */\nexport interface InviteToken {\n  /** Token ID (8 chars) - used for URL lookup */\n  id: string;\n  /** SHA256 hash of the actual token value - never store raw token */\n  tokenHash: string;\n  /** Plan ID this token is for */\n  planId: string;\n  /** GitHub username of creator (plan owner) */\n  createdBy: string;\n  /** Unix timestamp when created */\n  createdAt: number;\n  /** Unix timestamp when token expires */\n  expiresAt: number;\n  /** Max number of times token can be used (null = unlimited) */\n  maxUses: number | null;\n  /** Current number of times token has been used */\n  useCount: number;\n  /** Whether token has been manually revoked */\n  revoked: boolean;\n  /** Optional label for the invite (e.g., \"Team review\", \"PR #42\") */\n  label?: string;\n}\n\nexport const InviteTokenSchema = z.object({\n  id: z.string(),\n  tokenHash: z.string(),\n  planId: z.string(),\n  createdBy: z.string(),\n  createdAt: z.number(),\n  expiresAt: z.number(),\n  maxUses: z.number().nullable(),\n  useCount: z.number(),\n  revoked: z.boolean(),\n  label: z.string().optional(),\n});\n\n/**\n * Record of who redeemed an invite token.\n */\nexport interface InviteRedemption {\n  /** User who redeemed */\n  redeemedBy: string;\n  /** When redeemed */\n  redeemedAt: number;\n  /** Token ID that was redeemed */\n  tokenId: string;\n}\n\nexport const InviteRedemptionSchema = z.object({\n  redeemedBy: z.string(),\n  redeemedAt: z.number(),\n  tokenId: z.string(),\n});\n\n/**\n * Request to create a new invite token (owner only).\n */\nexport interface CreateInviteRequest {\n  type: 'create_invite';\n  planId: string;\n  /** TTL in minutes (default: 30) */\n  ttlMinutes?: number;\n  /** Max uses (null = unlimited, default: null) */\n  maxUses?: number | null;\n  /** Optional label */\n  label?: string;\n}\n\n/**\n * Response with created invite token.\n * tokenValue is only sent once - store it immediately!\n */\nexport interface InviteCreatedResponse {\n  type: 'invite_created';\n  tokenId: string;\n  /** The actual token value - only sent once on creation! */\n  tokenValue: string;\n  expiresAt: number;\n  maxUses: number | null;\n  label?: string;\n}\n\n/**\n * Request to redeem an invite token (guest).\n */\nexport interface RedeemInviteRequest {\n  type: 'redeem_invite';\n  planId: string;\n  tokenId: string;\n  tokenValue: string;\n  userId: string;\n}\n\n/**\n * Response to invite redemption attempt.\n */\nexport type InviteRedemptionResult =\n  | {\n      type: 'invite_redemption_result';\n      success: true;\n      planId: string;\n    }\n  | {\n      type: 'invite_redemption_result';\n      success: false;\n      error: 'expired' | 'exhausted' | 'revoked' | 'invalid' | 'already_redeemed';\n    };\n\n/**\n * Request to revoke an invite token (owner only).\n */\nexport interface RevokeInviteRequest {\n  type: 'revoke_invite';\n  planId: string;\n  tokenId: string;\n}\n\n/**\n * Response to invite revocation.\n */\nexport interface InviteRevokedResponse {\n  type: 'invite_revoked';\n  tokenId: string;\n  success: boolean;\n}\n\n/**\n * Request to list active invites (owner only).\n */\nexport interface ListInvitesRequest {\n  type: 'list_invites';\n  planId: string;\n}\n\n/**\n * Response with active invites list.\n */\nexport interface InvitesListResponse {\n  type: 'invites_list';\n  planId: string;\n  invites: Array<{\n    tokenId: string;\n    label?: string;\n    expiresAt: number;\n    maxUses: number | null;\n    useCount: number;\n    createdAt: number;\n  }>;\n}\n\n/**\n * Notification to owner when someone redeems an invite.\n */\nexport interface InviteRedeemedNotification {\n  type: 'invite_redeemed';\n  planId: string;\n  tokenId: string;\n  label?: string;\n  redeemedBy: string;\n  useCount: number;\n  maxUses: number | null;\n}\n\nexport type InviteSignalingMessage =\n  | CreateInviteRequest\n  | RedeemInviteRequest\n  | RevokeInviteRequest\n  | ListInvitesRequest;\n\nexport type InviteSignalingResponse =\n  | InviteCreatedResponse\n  | InviteRedemptionResult\n  | InviteRevokedResponse\n  | InvitesListResponse\n  | InviteRedeemedNotification;\n\n/**\n * Parse invite token from URL query parameter.\n * Format: ?invite={tokenId}:{tokenValue}\n */\nexport function parseInviteFromUrl(url: string): { tokenId: string; tokenValue: string } | null {\n  try {\n    const urlObj = new URL(url);\n    const inviteParam = urlObj.searchParams.get('invite');\n    if (!inviteParam) return null;\n\n    const [tokenId, tokenValue] = inviteParam.split(':');\n    if (!tokenId || !tokenValue) return null;\n\n    return { tokenId, tokenValue };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Build invite URL from plan URL and token.\n * baseUrl should include the deployment base path (e.g., https://example.com/shipyard)\n */\nexport function buildInviteUrl(\n  baseUrl: string,\n  planId: string,\n  tokenId: string,\n  tokenValue: string\n): string {\n  const normalizedBase = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;\n  const url = new URL(`${normalizedBase}/task/${planId}`);\n  url.searchParams.set('invite', `${tokenId}:${tokenValue}`);\n  return url.toString();\n}\n\n/**\n * Calculate time remaining until token expiration.\n */\nexport function getTokenTimeRemaining(expiresAt: number): {\n  expired: boolean;\n  minutes: number;\n  formatted: string;\n} {\n  const now = Date.now();\n  const remaining = expiresAt - now;\n\n  if (remaining <= 0) {\n    return { expired: true, minutes: 0, formatted: 'Expired' };\n  }\n\n  const minutes = Math.ceil(remaining / 60000);\n  if (minutes >= 60) {\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    return {\n      expired: false,\n      minutes,\n      formatted: mins > 0 ? `${hours}h ${mins}m` : `${hours}h`,\n    };\n  }\n\n  return {\n    expired: false,\n    minutes,\n    formatted: `${minutes}m`,\n  };\n}\n","/**\n * P2P Message Protocol for Context Teleportation\n *\n * This module defines the message types and schemas for peer-to-peer\n * conversation transfer over WebRTC data channels.\n *\n * Message type bytes are chosen to not conflict with Yjs protocol:\n * - Yjs uses 0x00-0x04 for its internal messages\n * - We use 0xF0-0xF2 for conversation transfer\n *\n * @see Issue #41 - Context Teleportation\n * @see docs/designs/webrtc-custom-messages-research.md\n */\n\nimport { z } from 'zod';\n\n/**\n * P2P message type bytes.\n * These are carefully chosen to avoid conflicts with Yjs protocol (0x00-0x04).\n */\nexport const P2PMessageType = {\n  CONVERSATION_EXPORT_START: 0xf0,\n  CONVERSATION_CHUNK: 0xf1,\n  CONVERSATION_EXPORT_END: 0xf2,\n} as const;\n\nexport type P2PMessageTypeValue = (typeof P2PMessageType)[keyof typeof P2PMessageType];\n\n/**\n * Metadata sent at the start of a conversation export transfer.\n * Contains all information needed to reassemble the conversation.\n */\nexport const ConversationExportStartMetaSchema = z.object({\n  /** Unique ID for this transfer (used to match chunks) */\n  exportId: z.string(),\n  /** Total number of chunks to expect */\n  totalChunks: z.number().int().positive(),\n  /** Total size in bytes (uncompressed) */\n  totalBytes: z.number().int().nonnegative(),\n  /** Compressed size in bytes */\n  compressedBytes: z.number().int().nonnegative(),\n  /** Source platform (e.g., 'claude-code', 'devin', 'cursor') */\n  sourcePlatform: z.string(),\n  /** Session ID from the source platform */\n  sourceSessionId: z.string(),\n  /** Plan ID this conversation belongs to */\n  planId: z.string(),\n  /** Timestamp when export was initiated (Unix ms) */\n  exportedAt: z.number().int().positive(),\n});\nexport type ConversationExportStartMeta = z.infer<typeof ConversationExportStartMetaSchema>;\n\n/**\n * A single chunk of conversation data.\n */\nexport const ChunkMessageSchema = z.object({\n  /** Export ID this chunk belongs to */\n  exportId: z.string(),\n  /** Zero-based index of this chunk */\n  chunkIndex: z.number().int().nonnegative(),\n  /** Raw chunk data (compressed bytes) */\n  data: z.instanceof(Uint8Array),\n});\nexport type ChunkMessage = z.infer<typeof ChunkMessageSchema>;\n\n/**\n * End message sent after all chunks, contains checksum for verification.\n */\nexport const ConversationExportEndSchema = z.object({\n  /** Export ID this end message belongs to */\n  exportId: z.string(),\n  /** SHA-256 checksum of the full compressed data (hex string) */\n  checksum: z.string(),\n});\nexport type ConversationExportEnd = z.infer<typeof ConversationExportEndSchema>;\n\n/**\n * Checks if a Uint8Array is a P2P conversation export start message.\n */\nexport function isConversationExportStart(data: Uint8Array): boolean {\n  return data.length > 0 && data[0] === P2PMessageType.CONVERSATION_EXPORT_START;\n}\n\n/**\n * Checks if a Uint8Array is a P2P conversation chunk message.\n */\nexport function isConversationChunk(data: Uint8Array): boolean {\n  return data.length > 0 && data[0] === P2PMessageType.CONVERSATION_CHUNK;\n}\n\n/**\n * Checks if a Uint8Array is a P2P conversation export end message.\n */\nexport function isConversationExportEnd(data: Uint8Array): boolean {\n  return data.length > 0 && data[0] === P2PMessageType.CONVERSATION_EXPORT_END;\n}\n\n/**\n * Checks if a Uint8Array is any P2P conversation transfer message.\n */\nexport function isP2PConversationMessage(data: Uint8Array): boolean {\n  if (data.length === 0) return false;\n  const type = data[0];\n  return (\n    type === P2PMessageType.CONVERSATION_EXPORT_START ||\n    type === P2PMessageType.CONVERSATION_CHUNK ||\n    type === P2PMessageType.CONVERSATION_EXPORT_END\n  );\n}\n\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n\n/**\n * Encodes a conversation export start message.\n * Format: [type byte (1)] [JSON metadata]\n */\nexport function encodeExportStartMessage(meta: ConversationExportStartMeta): Uint8Array {\n  const jsonBytes = textEncoder.encode(JSON.stringify(meta));\n  const result = new Uint8Array(1 + jsonBytes.length);\n  result[0] = P2PMessageType.CONVERSATION_EXPORT_START;\n  result.set(jsonBytes, 1);\n  return result;\n}\n\n/**\n * Decodes a conversation export start message.\n * @throws {Error} If the message is malformed or validation fails\n */\nexport function decodeExportStartMessage(data: Uint8Array): ConversationExportStartMeta {\n  if (data.length === 0 || data[0] !== P2PMessageType.CONVERSATION_EXPORT_START) {\n    throw new Error('Invalid export start message: wrong type byte');\n  }\n  const jsonStr = textDecoder.decode(data.slice(1));\n  const parsed: unknown = JSON.parse(jsonStr);\n  return ConversationExportStartMetaSchema.parse(parsed);\n}\n\n/**\n * Encodes a chunk message.\n * Format: [type byte (1)] [exportId length (4)] [exportId] [chunkIndex (4)] [data]\n */\nexport function encodeChunkMessage(chunk: ChunkMessage): Uint8Array {\n  const exportIdBytes = textEncoder.encode(chunk.exportId);\n  const result = new Uint8Array(1 + 4 + exportIdBytes.length + 4 + chunk.data.length);\n  let offset = 0;\n\n  result[offset] = P2PMessageType.CONVERSATION_CHUNK;\n  offset += 1;\n\n  const view = new DataView(result.buffer);\n  view.setUint32(offset, exportIdBytes.length, false);\n  offset += 4;\n\n  result.set(exportIdBytes, offset);\n  offset += exportIdBytes.length;\n\n  view.setUint32(offset, chunk.chunkIndex, false);\n  offset += 4;\n\n  result.set(chunk.data, offset);\n\n  return result;\n}\n\n/**\n * Decodes a chunk message.\n * @throws {Error} If the message is malformed\n */\nexport function decodeChunkMessage(data: Uint8Array): ChunkMessage {\n  if (data.length < 9 || data[0] !== P2PMessageType.CONVERSATION_CHUNK) {\n    throw new Error('Invalid chunk message: too short or wrong type byte');\n  }\n\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  let offset = 1;\n\n  const exportIdLength = view.getUint32(offset, false);\n  offset += 4;\n\n  if (data.length < 9 + exportIdLength) {\n    throw new Error('Invalid chunk message: exportId extends beyond message');\n  }\n\n  const exportId = textDecoder.decode(data.slice(offset, offset + exportIdLength));\n  offset += exportIdLength;\n\n  const chunkIndex = view.getUint32(offset, false);\n  offset += 4;\n\n  const chunkData = data.slice(offset);\n\n  return ChunkMessageSchema.parse({\n    exportId,\n    chunkIndex,\n    data: chunkData,\n  });\n}\n\n/**\n * Encodes a conversation export end message.\n * Format: [type byte (1)] [JSON payload]\n */\nexport function encodeExportEndMessage(end: ConversationExportEnd): Uint8Array {\n  const jsonBytes = textEncoder.encode(JSON.stringify(end));\n  const result = new Uint8Array(1 + jsonBytes.length);\n  result[0] = P2PMessageType.CONVERSATION_EXPORT_END;\n  result.set(jsonBytes, 1);\n  return result;\n}\n\n/**\n * Decodes a conversation export end message.\n * @throws {Error} If the message is malformed or validation fails\n */\nexport function decodeExportEndMessage(data: Uint8Array): ConversationExportEnd {\n  if (data.length === 0 || data[0] !== P2PMessageType.CONVERSATION_EXPORT_END) {\n    throw new Error('Invalid export end message: wrong type byte');\n  }\n  const jsonStr = textDecoder.decode(data.slice(1));\n  const parsed: unknown = JSON.parse(jsonStr);\n  return ConversationExportEndSchema.parse(parsed);\n}\n\n/**\n * Decoded P2P message with discriminated union type.\n */\nexport type DecodedP2PMessage =\n  | { type: 'export_start'; payload: ConversationExportStartMeta }\n  | { type: 'chunk'; payload: ChunkMessage }\n  | { type: 'export_end'; payload: ConversationExportEnd };\n\n/**\n * Decodes any P2P conversation message into a discriminated union.\n * @throws {Error} If the message is not a valid P2P message\n */\nexport function decodeP2PMessage(data: Uint8Array): DecodedP2PMessage {\n  if (data.length === 0) {\n    throw new Error('Cannot decode empty message');\n  }\n\n  const type = data[0];\n  if (type === undefined) {\n    throw new Error('Message type byte is missing');\n  }\n\n  switch (type) {\n    case P2PMessageType.CONVERSATION_EXPORT_START:\n      return { type: 'export_start', payload: decodeExportStartMessage(data) };\n    case P2PMessageType.CONVERSATION_CHUNK:\n      return { type: 'chunk', payload: decodeChunkMessage(data) };\n    case P2PMessageType.CONVERSATION_EXPORT_END:\n      return { type: 'export_end', payload: decodeExportEndMessage(data) };\n    default:\n      throw new Error(`Unknown P2P message type: 0x${type.toString(16)}`);\n  }\n}\n\n/**\n * Helper to ensure exhaustive handling of decoded messages.\n */\nexport function assertNeverP2PMessage(msg: never): never {\n  throw new Error(`Unhandled P2P message type: ${JSON.stringify(msg)}`);\n}\n","import { z } from 'zod';\nimport { type PlanStatusType, PlanStatusValues } from './plan.js';\n\n/**\n * The document name for the plan index Y.Doc.\n * This is a special Y.Doc that tracks all plan metadata for the sidebar.\n */\nexport const PLAN_INDEX_DOC_NAME = 'plan-index';\n\n/**\n * The key for the viewedBy map within the plan-index Y.Doc.\n * Stores per-plan viewedBy data as nested Y.Maps for CRDT merging.\n * Structure: Y.Map<planId, Y.Map<username, timestamp>>\n */\nexport const PLAN_INDEX_VIEWED_BY_KEY = 'viewedBy';\n\n/**\n * Known IndexedDB database names that are NOT plan documents.\n * Used to filter when querying for shared plans.\n */\nexport const NON_PLAN_DB_NAMES = ['plan-index', 'idb-keyval'] as const;\n\nexport type { PlanStatusType };\n\n/**\n * Base fields shared by all plan index entries.\n */\ninterface PlanIndexEntryBase {\n  id: string;\n  title: string;\n  status: PlanStatusType;\n  createdAt: number;\n  updatedAt: number;\n  /** GitHub username of the plan owner */\n  ownerId: string;\n  /** Tags for categorization (copied from plan metadata for fast filtering) */\n  tags?: string[];\n}\n\n/**\n * Plan summary for the index (minimal data for sidebar display).\n * Uses a discriminated union to ensure deletedAt and deletedBy always appear together.\n */\nexport type PlanIndexEntry =\n  | (PlanIndexEntryBase & { deleted: false })\n  | (PlanIndexEntryBase & {\n      deleted: true;\n      /** Timestamp when plan was archived/deleted (hidden from sidebar by default) */\n      deletedAt: number;\n      /** Display name of who archived/deleted the plan */\n      deletedBy: string;\n    });\n\n/**\n * Zod schema for validating plan index entries from Y.Map.\n * Uses discriminated union on 'deleted' field for better validation performance.\n */\nexport const PlanIndexEntrySchema = z.discriminatedUnion('deleted', [\n  z.object({\n    deleted: z.literal(false),\n    id: z.string(),\n    title: z.string(),\n    status: z.enum(PlanStatusValues),\n    createdAt: z.number(),\n    updatedAt: z.number(),\n    ownerId: z.string(),\n    tags: z.array(z.string()).optional(),\n  }),\n  z.object({\n    deleted: z.literal(true),\n    id: z.string(),\n    title: z.string(),\n    status: z.enum(PlanStatusValues),\n    createdAt: z.number(),\n    updatedAt: z.number(),\n    ownerId: z.string(),\n    tags: z.array(z.string()).optional(),\n    deletedAt: z.number(),\n    deletedBy: z.string(),\n  }),\n]);\n","import * as Y from 'yjs';\nimport {\n  PLAN_INDEX_VIEWED_BY_KEY,\n  type PlanIndexEntry,\n  PlanIndexEntrySchema,\n} from './plan-index.js';\nimport { YDOC_KEYS } from './yjs-keys.js';\n\n/**\n * Gets all plans from the index Y.Doc, sorted by updatedAt (most recent first).\n * By default, filters out archived plans. Pass includeArchived=true to get all plans.\n */\nexport function getPlanIndex(ydoc: Y.Doc, includeArchived = false): PlanIndexEntry[] {\n  const plansMap = ydoc.getMap<PlanIndexEntry>(YDOC_KEYS.PLANS);\n  const entries: PlanIndexEntry[] = [];\n\n  for (const [_id, data] of plansMap.entries()) {\n    const result = PlanIndexEntrySchema.safeParse(data);\n    if (result.success) {\n      if (!includeArchived && result.data.deleted) {\n        continue;\n      }\n      entries.push(result.data);\n    }\n  }\n\n  return entries.sort((a, b) => b.updatedAt - a.updatedAt);\n}\n\n/**\n * Gets a single plan entry from the index.\n */\nexport function getPlanIndexEntry(ydoc: Y.Doc, planId: string): PlanIndexEntry | null {\n  const plansMap = ydoc.getMap<PlanIndexEntry>(YDOC_KEYS.PLANS);\n  const data = plansMap.get(planId);\n  if (!data) return null;\n\n  const result = PlanIndexEntrySchema.safeParse(data);\n  return result.success ? result.data : null;\n}\n\n/**\n * Adds or updates a plan in the index.\n */\nexport function setPlanIndexEntry(ydoc: Y.Doc, entry: PlanIndexEntry): void {\n  /*\n   * CRITICAL: Validate BEFORE accessing Y.Doc to prevent partial writes on validation failure.\n   * Validates discriminated union (deleted: true | false).\n   *\n   * Why validation-first pattern matters:\n   * - If validation throws after Y.Doc access, Y.Doc may contain partial/corrupted state\n   * - Pre-validation ensures atomic all-or-nothing behavior\n   * - Failed validation returns clear error without touching Y.Doc\n   */\n  const validated = PlanIndexEntrySchema.parse(entry);\n\n  const plansMap = ydoc.getMap<PlanIndexEntry>(YDOC_KEYS.PLANS);\n  plansMap.set(validated.id, validated);\n}\n\n/**\n * Removes a plan from the index.\n */\nexport function removePlanIndexEntry(ydoc: Y.Doc, planId: string): void {\n  const plansMap = ydoc.getMap<PlanIndexEntry>(YDOC_KEYS.PLANS);\n  plansMap.delete(planId);\n}\n\n/**\n * Updates only the updatedAt timestamp for a plan in the index.\n * Useful when plan content changes but not metadata.\n */\nexport function touchPlanIndexEntry(ydoc: Y.Doc, planId: string): void {\n  const entry = getPlanIndexEntry(ydoc, planId);\n  if (entry) {\n    setPlanIndexEntry(ydoc, { ...entry, updatedAt: Date.now() });\n  }\n}\n\n/**\n * Gets the viewedBy map for a plan from the plan-index.\n * Returns empty object if no viewedBy data exists.\n */\nexport function getViewedByFromIndex(ydoc: Y.Doc, planId: string): Record<string, number> {\n  const viewedByRoot = ydoc.getMap<Y.Map<number>>(PLAN_INDEX_VIEWED_BY_KEY);\n  const planViewedBy = viewedByRoot.get(planId);\n\n  if (!planViewedBy || !(planViewedBy instanceof Y.Map)) {\n    return {};\n  }\n\n  const result: Record<string, number> = {};\n  for (const [username, timestamp] of planViewedBy.entries()) {\n    if (typeof timestamp === 'number') {\n      result[username] = timestamp;\n    }\n  }\n  return result;\n}\n\n/**\n * Updates viewedBy for a plan in the plan-index.\n * Uses nested Y.Map for proper CRDT merging of concurrent edits.\n */\nexport function updatePlanIndexViewedBy(ydoc: Y.Doc, planId: string, username: string): void {\n  ydoc.transact(() => {\n    const viewedByRoot = ydoc.getMap<Y.Map<number>>(PLAN_INDEX_VIEWED_BY_KEY);\n\n    let planViewedBy = viewedByRoot.get(planId);\n    if (!planViewedBy || !(planViewedBy instanceof Y.Map)) {\n      planViewedBy = new Y.Map<number>();\n      viewedByRoot.set(planId, planViewedBy);\n    }\n\n    planViewedBy.set(username, Date.now());\n  });\n}\n\n/**\n * Clears viewedBy for a plan in the plan-index (marks as unread).\n * Removes the user's timestamp, making the plan appear unread again.\n */\nexport function clearPlanIndexViewedBy(ydoc: Y.Doc, planId: string, username: string): void {\n  ydoc.transact(() => {\n    const viewedByRoot = ydoc.getMap<Y.Map<number>>(PLAN_INDEX_VIEWED_BY_KEY);\n    const planViewedBy = viewedByRoot.get(planId);\n\n    if (planViewedBy && planViewedBy instanceof Y.Map) {\n      planViewedBy.delete(username);\n    }\n  });\n}\n\n/**\n * Gets all viewedBy data from the plan-index for multiple plans.\n * Efficient batch read for inbox calculations.\n */\nexport function getAllViewedByFromIndex(\n  ydoc: Y.Doc,\n  planIds: string[]\n): Record<string, Record<string, number>> {\n  const result: Record<string, Record<string, number>> = {};\n\n  for (const planId of planIds) {\n    result[planId] = getViewedByFromIndex(ydoc, planId);\n  }\n\n  return result;\n}\n\n/**\n * Removes viewedBy data for a plan (call when plan is deleted).\n */\nexport function removeViewedByFromIndex(ydoc: Y.Doc, planId: string): void {\n  const viewedByRoot = ydoc.getMap<Y.Map<number>>(PLAN_INDEX_VIEWED_BY_KEY);\n  viewedByRoot.delete(planId);\n}\n\n/**\n * Key for event-level read tracking in plan-index.\n * Structure: event-viewedBy[planId][eventId][username] = timestamp\n */\nexport const PLAN_INDEX_EVENT_VIEWED_BY_KEY = 'event-viewedBy' as const;\n\n/**\n * Mark an event as viewed by a user.\n */\nexport function markEventAsViewed(\n  ydoc: Y.Doc,\n  planId: string,\n  eventId: string,\n  username: string\n): void {\n  const viewedByRoot = ydoc.getMap(PLAN_INDEX_EVENT_VIEWED_BY_KEY);\n  let planEvents = viewedByRoot.get(planId) as Y.Map<Y.Map<number>> | undefined;\n\n  if (!planEvents) {\n    planEvents = new Y.Map();\n    viewedByRoot.set(planId, planEvents);\n  }\n\n  let eventViews = planEvents.get(eventId) as Y.Map<number> | undefined;\n  if (!eventViews) {\n    eventViews = new Y.Map();\n    planEvents.set(eventId, eventViews);\n  }\n\n  eventViews.set(username, Date.now());\n}\n\n/**\n * Clear event viewed status for a user (mark as unread).\n */\nexport function clearEventViewedBy(\n  ydoc: Y.Doc,\n  planId: string,\n  eventId: string,\n  username: string\n): void {\n  const viewedByRoot = ydoc.getMap(PLAN_INDEX_EVENT_VIEWED_BY_KEY);\n  const planEvents = viewedByRoot.get(planId) as Y.Map<Y.Map<number>> | undefined;\n\n  if (!planEvents) return;\n\n  const eventViews = planEvents.get(eventId) as Y.Map<number> | undefined;\n  if (!eventViews) return;\n\n  eventViews.delete(username);\n}\n\n/**\n * Check if an event is unread for a user.\n */\nexport function isEventUnread(\n  ydoc: Y.Doc,\n  planId: string,\n  eventId: string,\n  username: string\n): boolean {\n  const viewedByRoot = ydoc.getMap(PLAN_INDEX_EVENT_VIEWED_BY_KEY);\n  const planEvents = viewedByRoot.get(planId) as Y.Map<Y.Map<number>> | undefined;\n  if (!planEvents) return true;\n\n  const eventViews = planEvents.get(eventId) as Y.Map<number> | undefined;\n  if (!eventViews) return true;\n\n  return !eventViews.has(username);\n}\n\n/**\n * Get all event viewedBy data for a plan.\n * Returns map of eventId -> (username -> timestamp).\n */\nexport function getAllEventViewedByForPlan(\n  ydoc: Y.Doc,\n  planId: string\n): Record<string, Record<string, number>> {\n  const viewedByRoot = ydoc.getMap(PLAN_INDEX_EVENT_VIEWED_BY_KEY);\n  const planEvents = viewedByRoot.get(planId) as Y.Map<Y.Map<number>> | undefined;\n\n  if (!planEvents) return {};\n\n  const result: Record<string, Record<string, number>> = {};\n\n  for (const [eventId, eventViews] of planEvents.entries()) {\n    const views = eventViews as Y.Map<number>;\n    result[eventId] = Object.fromEntries(views.entries());\n  }\n\n  return result;\n}\n","/**\n * Type-safe API route definitions for registry server.\n * Use these instead of hardcoded strings to prevent typos.\n */\n\nexport const ROUTES = {\n  REGISTRY_LIST: '/registry',\n  REGISTRY_REGISTER: '/register',\n  REGISTRY_UNREGISTER: '/unregister',\n\n  PLAN_STATUS: (planId: string) => `/api/plan/${planId}/status`,\n  PLAN_HAS_CONNECTIONS: (planId: string) => `/api/plan/${planId}/has-connections`,\n  PLAN_TRANSCRIPT: (planId: string) => `/api/plan/${planId}/transcript`,\n  PLAN_SUBSCRIBE: (planId: string) => `/api/plan/${planId}/subscribe`,\n  PLAN_CHANGES: (planId: string) => `/api/plan/${planId}/changes`,\n  PLAN_UNSUBSCRIBE: (planId: string) => `/api/plan/${planId}/unsubscribe`,\n\n  PLAN_PR_DIFF: (planId: string, prNumber: number) => `/api/plans/${planId}/pr-diff/${prNumber}`,\n  PLAN_PR_FILES: (planId: string, prNumber: number) => `/api/plans/${planId}/pr-files/${prNumber}`,\n\n  HOOK_SESSION: '/api/hook/session',\n  HOOK_CONTENT: (planId: string) => `/api/hook/plan/${planId}/content`,\n  HOOK_REVIEW: (planId: string) => `/api/hook/plan/${planId}/review`,\n  HOOK_SESSION_TOKEN: (planId: string) => `/api/hook/plan/${planId}/session-token`,\n  HOOK_PRESENCE: (planId: string) => `/api/hook/plan/${planId}/presence`,\n\n  CONVERSATION_IMPORT: '/api/conversation/import',\n} as const;\n\nexport type RoutePath = (typeof ROUTES)[keyof typeof ROUTES];\n","/**\n * Shared thread formatting utilities for LLM-friendly output.\n * Used by both MCP server (read_plan) and hook (ExitPlanMode denial).\n */\n\nimport type { Thread } from './thread.js';\nimport { extractTextFromCommentBody } from './thread.js';\n\nexport interface FormatThreadsOptions {\n  /** Include resolved threads (default: false) */\n  includeResolved?: boolean;\n  /** Max length for selected text preview (default: 100) */\n  selectedTextMaxLength?: number;\n  /** Function to resolve user IDs to display names */\n  resolveUser?: (userId: string) => string;\n}\n\n/**\n * Format comment threads for LLM consumption.\n * Returns clean, readable feedback text.\n */\nexport function formatThreadsForLLM(threads: Thread[], options: FormatThreadsOptions = {}): string {\n  const { includeResolved = false, selectedTextMaxLength = 100, resolveUser } = options;\n\n  const unresolvedThreads = threads.filter((t) => !t.resolved);\n  const resolvedCount = threads.length - unresolvedThreads.length;\n  const threadsToShow = includeResolved ? threads : unresolvedThreads;\n\n  if (threadsToShow.length === 0) {\n    if (resolvedCount > 0) {\n      return `All ${resolvedCount} comment(s) have been resolved.`;\n    }\n    return '';\n  }\n\n  const feedbackLines = threadsToShow.map((thread, index) => {\n    const location = thread.selectedText\n      ? `On: \"${truncate(thread.selectedText, selectedTextMaxLength)}\"`\n      : `Comment ${index + 1}`;\n\n    const comments = thread.comments\n      .map((c, idx) => {\n        const text = extractTextFromCommentBody(c.body);\n        const author = resolveUser ? resolveUser(c.userId) : c.userId.slice(0, 8);\n\n        if (idx === 0) {\n          return `${author}: ${text}`;\n        }\n        return `${author} (reply): ${text}`;\n      })\n      .join('\\n');\n\n    const resolvedMarker = thread.resolved ? ' [Resolved]' : '';\n    return `${location}${resolvedMarker}\\n${comments}`;\n  });\n\n  let output = feedbackLines.join('\\n\\n');\n\n  if (!includeResolved && resolvedCount > 0) {\n    output += `\\n\\n---\\n(${resolvedCount} resolved comment(s) not shown)`;\n  }\n\n  return output;\n}\n\nfunction truncate(text: string, maxLength: number): string {\n  const cleaned = text.replace(/\\n/g, ' ').trim();\n  if (cleaned.length <= maxLength) {\n    return cleaned;\n  }\n  return `${cleaned.slice(0, maxLength)}...`;\n}\n","/**\n * Additional Zod schemas for tRPC procedures.\n * Re-exports existing schemas and adds new ones needed for tRPC.\n */\n\nimport { z } from 'zod';\nimport { A2AMessageSchema } from '../conversation-export.js';\n\nexport { A2AMessageSchema, ConversationExportMetaSchema } from '../conversation-export.js';\nexport {\n  CreateHookSessionRequestSchema,\n  CreateHookSessionResponseSchema,\n  CreateSubscriptionRequestSchema,\n  CreateSubscriptionResponseSchema,\n  GetReviewStatusResponseSchema,\n  UpdatePlanContentRequestSchema,\n  UpdatePlanContentResponseSchema,\n  UpdatePresenceRequestSchema,\n  UpdatePresenceResponseSchema,\n} from '../hook-api.js';\nexport { getPlanMetadata } from '../yjs-helpers.js';\n\nexport const PlanIdSchema = z.object({\n  planId: z.string().min(1),\n});\n\nexport type PlanIdInput = z.infer<typeof PlanIdSchema>;\n\nexport const PlanStatusResponseSchema = z.object({\n  status: z.string(),\n});\n\nexport type PlanStatusResponse = z.infer<typeof PlanStatusResponseSchema>;\n\nexport const HasConnectionsResponseSchema = z.object({\n  hasConnections: z.boolean(),\n});\n\nexport type HasConnectionsResponse = z.infer<typeof HasConnectionsResponseSchema>;\n\nexport const SubscriptionClientIdSchema = z.object({\n  planId: z.string().min(1),\n  clientId: z.string().min(1),\n});\n\nexport type SubscriptionClientIdInput = z.infer<typeof SubscriptionClientIdSchema>;\n\nexport const ChangeTypeSchema = z.enum(['status', 'comments', 'resolved', 'content', 'artifacts']);\n\nexport type ChangeType = z.infer<typeof ChangeTypeSchema>;\n\nexport const ChangeSchema = z.object({\n  type: ChangeTypeSchema,\n  timestamp: z.number(),\n  summary: z.string(),\n  details: z.record(z.string(), z.unknown()).optional(),\n});\n\nexport type Change = z.infer<typeof ChangeSchema>;\n\nexport const ChangesResponseSchema = z.discriminatedUnion('ready', [\n  z.object({\n    ready: z.literal(true),\n    changes: z.string(),\n    details: z.array(ChangeSchema),\n  }),\n  z.object({\n    ready: z.literal(false),\n    pending: z.number(),\n    windowExpiresIn: z.number(),\n  }),\n]);\n\nexport type ChangesResponse = z.infer<typeof ChangesResponseSchema>;\n\nexport const DeleteSubscriptionResponseSchema = z.object({\n  success: z.boolean(),\n});\n\nexport type DeleteSubscriptionResponse = z.infer<typeof DeleteSubscriptionResponseSchema>;\n\nexport interface SubscriptionCreateParams {\n  planId: string;\n  subscribe: ChangeType[];\n  windowMs: number;\n  maxWindowMs: number;\n  threshold: number;\n}\n\nexport const SetSessionTokenRequestSchema = z.object({\n  sessionTokenHash: z.string().min(1),\n});\n\nexport type SetSessionTokenRequest = z.infer<typeof SetSessionTokenRequestSchema>;\n\nexport const GetDeliverableContextRequestSchema = z.object({\n  sessionToken: z.string().min(1),\n});\n\nexport type GetDeliverableContextRequest = z.infer<typeof GetDeliverableContextRequestSchema>;\n\nexport const GetDeliverableContextResponseSchema = z.object({\n  context: z.string(),\n});\n\nexport type GetDeliverableContextResponse = z.infer<typeof GetDeliverableContextResponseSchema>;\n\nexport const SetSessionTokenResponseSchema = z.object({\n  url: z.string(),\n});\n\nexport type SetSessionTokenResponse = z.infer<typeof SetSessionTokenResponseSchema>;\n\nexport const ImportConversationRequestSchema = z.object({\n  a2aMessages: z.array(A2AMessageSchema),\n  meta: z\n    .object({\n      planId: z.string().optional(),\n      sourcePlatform: z.string().optional(),\n      sessionId: z.string().optional(),\n    })\n    .optional(),\n});\n\nexport type ImportConversationRequest = z.infer<typeof ImportConversationRequestSchema>;\n\nexport const ImportConversationResponseSchema = z.discriminatedUnion('success', [\n  z.object({\n    success: z.literal(true),\n    sessionId: z.string(),\n    transcriptPath: z.string(),\n    messageCount: z.number(),\n  }),\n  z.object({\n    success: z.literal(false),\n    error: z.string(),\n  }),\n]);\n\nexport type ImportConversationResponse = z.infer<typeof ImportConversationResponseSchema>;\n","/**\n * tRPC initialization for shipyard.\n * Provides the base router and procedure builders.\n */\n\nimport { initTRPC } from '@trpc/server';\nimport type { Context } from './context.js';\n\nconst t = initTRPC.context<Context>().create({\n  /**\n   * Allow @trpc/server to be bundled in browser environments.\n   * This is needed because the schema package exports router types that\n   * get bundled into the web app for type inference.\n   * The routers are never actually called in the browser - only the types are used.\n   * See: https://trpc.io/docs/server/routers\n   */\n  allowOutsideOfServer: true,\n});\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\nexport const middleware = t.middleware;\n","/**\n * tRPC router for conversation import/export.\n * Handles A2A protocol message conversion and Claude Code session creation.\n */\n\nimport type { Logger } from '../context.js';\nimport { ImportConversationRequestSchema, ImportConversationResponseSchema } from '../schemas.js';\nimport { publicProcedure, router } from '../trpc.js';\n\n/**\n * Conversation router - handles conversation import from A2A protocol.\n *\n * Handler logic is injected via context since it requires filesystem access\n * and Claude Code specific paths that only the server package knows.\n */\nexport const conversationRouter = router({\n  /**\n   * Import a conversation from A2A format into a Claude Code session.\n   * POST /api/conversation/import\n   */\n  import: publicProcedure\n    .input(ImportConversationRequestSchema)\n    .output(ImportConversationResponseSchema)\n    .mutation(async ({ input, ctx }) => {\n      const handlers = ctx.conversationHandlers;\n      return handlers.importConversation(input, ctx);\n    }),\n});\n\n/**\n * Minimal context interface required by conversation handlers.\n * This avoids circular dependencies with the full Context type.\n */\nexport interface ConversationContext {\n  logger: Logger;\n}\n\n/**\n * Handler interface for conversation operations.\n * Implemented by server package to provide actual business logic.\n */\nexport interface ConversationHandlers {\n  importConversation: (\n    input: {\n      a2aMessages: unknown[];\n      meta?: {\n        planId?: string;\n        sourcePlatform?: string;\n        sessionId?: string;\n      };\n    },\n    ctx: ConversationContext\n  ) => Promise<\n    | { success: true; sessionId: string; transcriptPath: string; messageCount: number }\n    | { success: false; error: string }\n  >;\n}\n\nexport type ConversationRouter = typeof conversationRouter;\n","/**\n * tRPC router for hook API endpoints.\n * These endpoints are called by the Claude Code hook to manage plan sessions.\n */\n\nimport type * as Y from 'yjs';\nimport { z } from 'zod';\nimport type { Logger } from '../context.js';\nimport {\n  CreateHookSessionRequestSchema,\n  CreateHookSessionResponseSchema,\n  GetDeliverableContextRequestSchema,\n  GetDeliverableContextResponseSchema,\n  GetReviewStatusResponseSchema,\n  PlanIdSchema,\n  SetSessionTokenRequestSchema,\n  SetSessionTokenResponseSchema,\n  UpdatePlanContentRequestSchema,\n  UpdatePlanContentResponseSchema,\n  UpdatePresenceRequestSchema,\n  UpdatePresenceResponseSchema,\n} from '../schemas.js';\nimport { publicProcedure, router } from '../trpc.js';\n\n/**\n * Hook router - manages plan sessions from Claude Code hook.\n *\n * Handler logic is injected via context to keep this router package-agnostic.\n * The actual business logic lives in the server package's hook-handlers.ts.\n */\n\nexport type ApprovalResult =\n  | {\n      approved: true;\n      deliverables: unknown[];\n      reviewComment?: string;\n      reviewedBy: string;\n      status: 'in_progress';\n    }\n  | {\n      approved: false;\n      feedback: string;\n      status: 'changes_requested' | 'timeout';\n      reviewComment?: string;\n      reviewedBy?: string;\n    };\n\nexport type SessionContextResult =\n  | {\n      found: true;\n      planId: string;\n      sessionToken: string;\n      url: string;\n      deliverables: Array<{ id: string; text: string }>;\n      reviewComment?: string;\n      reviewedBy?: string;\n      reviewStatus?: string;\n    }\n  | { found: false };\n\nexport const hookRouter = router({\n  /**\n   * Create a new plan session.\n   * POST /api/hook/session\n   */\n  createSession: publicProcedure\n    .input(CreateHookSessionRequestSchema)\n    .output(CreateHookSessionResponseSchema)\n    .mutation(async ({ input, ctx }) => {\n      const handlers = ctx.hookHandlers;\n      return handlers.createSession(input, ctx);\n    }),\n\n  /**\n   * Update plan content with markdown.\n   * PUT /api/hook/plan/:id/content\n   */\n  updateContent: publicProcedure\n    .input(PlanIdSchema.merge(UpdatePlanContentRequestSchema))\n    .output(UpdatePlanContentResponseSchema)\n    .mutation(async ({ input, ctx }) => {\n      const { planId, ...contentInput } = input;\n      const handlers = ctx.hookHandlers;\n      return handlers.updateContent(planId, contentInput, ctx);\n    }),\n\n  /**\n   * Get review status for a plan.\n   * GET /api/hook/plan/:id/review\n   */\n  getReviewStatus: publicProcedure\n    .input(PlanIdSchema)\n    .output(GetReviewStatusResponseSchema)\n    .query(async ({ input, ctx }) => {\n      const handlers = ctx.hookHandlers;\n      return handlers.getReviewStatus(input.planId, ctx);\n    }),\n\n  /**\n   * Update agent presence in a plan.\n   * POST /api/hook/plan/:id/presence\n   */\n  updatePresence: publicProcedure\n    .input(PlanIdSchema.merge(UpdatePresenceRequestSchema))\n    .output(UpdatePresenceResponseSchema)\n    .mutation(async ({ input, ctx }) => {\n      const { planId, ...presenceInput } = input;\n      const handlers = ctx.hookHandlers;\n      return handlers.updatePresence(planId, presenceInput, ctx);\n    }),\n\n  /**\n   * Set session token for a plan.\n   * POST /api/hook/plan/:id/session-token\n   */\n  setSessionToken: publicProcedure\n    .input(PlanIdSchema.merge(SetSessionTokenRequestSchema))\n    .output(SetSessionTokenResponseSchema)\n    .mutation(async ({ input, ctx }) => {\n      const { planId, sessionTokenHash } = input;\n      const handlers = ctx.hookHandlers;\n      return handlers.setSessionToken(planId, sessionTokenHash, ctx);\n    }),\n\n  /**\n   * Wait for approval decision (blocking).\n   * Called by hook to wait for browser approval/rejection.\n   * POST /api/hook/plan/:id/wait-approval\n   */\n  waitForApproval: publicProcedure\n    .input(z.object({ planId: z.string(), reviewRequestId: z.string() }))\n    .output(\n      z.object({\n        approved: z.boolean(),\n        feedback: z.string().optional(),\n        deliverables: z.array(z.any()).optional(),\n        reviewComment: z.string().optional(),\n        reviewedBy: z.string().optional(),\n        status: z.string().optional(),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const { planId, reviewRequestId } = input;\n      const handlers = ctx.hookHandlers;\n      return handlers.waitForApproval(planId, reviewRequestId, ctx);\n    }),\n\n  /**\n   * Get formatted deliverable context for post-exit injection.\n   * Returns pre-formatted context string for Claude Code.\n   * GET /api/hook/plan/:id/deliverable-context\n   */\n  getDeliverableContext: publicProcedure\n    .input(PlanIdSchema.merge(GetDeliverableContextRequestSchema))\n    .output(GetDeliverableContextResponseSchema)\n    .query(async ({ input, ctx }) => {\n      const { planId, sessionToken } = input;\n      const handlers = ctx.hookHandlers;\n      return handlers.getDeliverableContext(planId, sessionToken, ctx);\n    }),\n\n  /**\n   * Get session context (for post-exit injection).\n   * Returns session data and deletes it from server registry.\n   * GET /api/hook/session/:sessionId/context\n   */\n  getSessionContext: publicProcedure\n    .input(z.object({ sessionId: z.string() }))\n    .output(\n      z.discriminatedUnion('found', [\n        z.object({\n          found: z.literal(true),\n          planId: z.string(),\n          sessionToken: z.string(),\n          url: z.string(),\n          deliverables: z.array(z.object({ id: z.string(), text: z.string() })),\n          reviewComment: z.string().optional(),\n          reviewedBy: z.string().optional(),\n          reviewStatus: z.string().optional(),\n        }),\n        z.object({ found: z.literal(false) }),\n      ])\n    )\n    .query(async ({ input, ctx }) => {\n      const handlers = ctx.hookHandlers;\n      return handlers.getSessionContext(input.sessionId, ctx);\n    }),\n});\n\n/**\n * Minimal context interface required by hook handlers.\n * This avoids circular dependencies with the full Context type.\n */\nexport interface HookContext {\n  getOrCreateDoc: (planId: string) => Promise<Y.Doc>;\n  logger: Logger;\n}\n\n/**\n * Handler interface for hook operations.\n * Implemented by server package to provide actual business logic.\n */\nexport interface HookHandlers {\n  createSession: (\n    input: z.infer<typeof CreateHookSessionRequestSchema>,\n    ctx: HookContext\n  ) => Promise<z.infer<typeof CreateHookSessionResponseSchema>>;\n\n  updateContent: (\n    planId: string,\n    input: z.infer<typeof UpdatePlanContentRequestSchema>,\n    ctx: HookContext\n  ) => Promise<z.infer<typeof UpdatePlanContentResponseSchema>>;\n\n  getReviewStatus: (\n    planId: string,\n    ctx: HookContext\n  ) => Promise<z.infer<typeof GetReviewStatusResponseSchema>>;\n\n  updatePresence: (\n    planId: string,\n    input: z.infer<typeof UpdatePresenceRequestSchema>,\n    ctx: HookContext\n  ) => Promise<z.infer<typeof UpdatePresenceResponseSchema>>;\n\n  setSessionToken: (\n    planId: string,\n    sessionTokenHash: string,\n    ctx: HookContext\n  ) => Promise<z.infer<typeof SetSessionTokenResponseSchema>>;\n\n  waitForApproval: (\n    planId: string,\n    reviewRequestId: string,\n    ctx: HookContext\n  ) => Promise<ApprovalResult>;\n\n  getDeliverableContext: (\n    planId: string,\n    sessionToken: string,\n    ctx: HookContext\n  ) => Promise<z.infer<typeof GetDeliverableContextResponseSchema>>;\n\n  getSessionContext: (sessionId: string, ctx: HookContext) => Promise<SessionContextResult>;\n}\n\nexport type HookRouter = typeof hookRouter;\n","/**\n * tRPC router for plan status and connection queries.\n */\n\nimport { TRPCError } from '@trpc/server';\nimport {\n  getPlanMetadata,\n  HasConnectionsResponseSchema,\n  PlanIdSchema,\n  PlanStatusResponseSchema,\n} from '../schemas.js';\nimport { publicProcedure, router } from '../trpc.js';\n\n/**\n * Plan router - queries plan status and connection state.\n */\nexport const planRouter = router({\n  /**\n   * Get the current status of a plan.\n   * GET /api/plan/:id/status\n   */\n  getStatus: publicProcedure\n    .input(PlanIdSchema)\n    .output(PlanStatusResponseSchema)\n    .query(async ({ input, ctx }) => {\n      const doc = await ctx.getOrCreateDoc(input.planId);\n      const metadata = getPlanMetadata(doc);\n\n      if (!metadata) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Plan not found',\n        });\n      }\n\n      return { status: metadata.status };\n    }),\n\n  /**\n   * Check if a plan has any active WebSocket connections.\n   * Used to avoid opening duplicate browser tabs.\n   * GET /api/plan/:id/has-connections\n   */\n  hasConnections: publicProcedure\n    .input(PlanIdSchema)\n    .output(HasConnectionsResponseSchema)\n    .query(async ({ input, ctx }) => {\n      const planStore = ctx.getPlanStore();\n      const hasConnections = await planStore.hasActiveConnections(input.planId);\n      return { hasConnections };\n    }),\n});\n\nexport type PlanRouter = typeof planRouter;\n","/**\n * tRPC router for plan change subscriptions.\n * Allows clients to subscribe to and poll for changes to a plan.\n */\n\nimport { TRPCError } from '@trpc/server';\nimport {\n  ChangesResponseSchema,\n  type ChangeType,\n  CreateSubscriptionRequestSchema,\n  CreateSubscriptionResponseSchema,\n  DeleteSubscriptionResponseSchema,\n  PlanIdSchema,\n  SubscriptionClientIdSchema,\n} from '../schemas.js';\nimport { publicProcedure, router } from '../trpc.js';\n\n/**\n * Subscription router - manages change notification subscriptions.\n */\nexport const subscriptionRouter = router({\n  /**\n   * Create a subscription to receive change notifications for a plan.\n   * POST /api/plan/:id/subscribe\n   */\n  create: publicProcedure\n    .input(PlanIdSchema.merge(CreateSubscriptionRequestSchema))\n    .output(CreateSubscriptionResponseSchema)\n    .mutation(async ({ input, ctx }) => {\n      const { planId, subscribe, windowMs, maxWindowMs, threshold } = input;\n      const planStore = ctx.getPlanStore();\n\n      const clientId = planStore.createSubscription({\n        planId,\n        subscribe: (subscribe || ['status']) as ChangeType[],\n        windowMs: windowMs ?? 5000,\n        maxWindowMs: maxWindowMs ?? 30000,\n        threshold: threshold ?? 1,\n      });\n\n      return { clientId };\n    }),\n\n  /**\n   * Get pending changes for a subscription.\n   * GET /api/plan/:id/changes?clientId=xxx\n   */\n  getChanges: publicProcedure\n    .input(SubscriptionClientIdSchema)\n    .output(ChangesResponseSchema)\n    .query(async ({ input, ctx }) => {\n      const { planId, clientId } = input;\n      const planStore = ctx.getPlanStore();\n\n      const result = planStore.getChanges(planId, clientId);\n      if (!result) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Subscription not found',\n        });\n      }\n\n      return result;\n    }),\n\n  /**\n   * Delete a subscription.\n   * DELETE /api/plan/:id/unsubscribe?clientId=xxx\n   */\n  delete: publicProcedure\n    .input(SubscriptionClientIdSchema)\n    .output(DeleteSubscriptionResponseSchema)\n    .mutation(async ({ input, ctx }) => {\n      const { planId, clientId } = input;\n      const planStore = ctx.getPlanStore();\n\n      const success = planStore.deleteSubscription(planId, clientId);\n      return { success };\n    }),\n});\n\nexport type SubscriptionRouter = typeof subscriptionRouter;\n","/**\n * tRPC router exports for shipyard.\n *\n * This module provides:\n * - Combined app router with all sub-routers\n * - Type exports for client type inference\n * - Context type for server implementation\n */\n\nimport { conversationRouter } from './routers/conversation.js';\nimport { hookRouter } from './routers/hook.js';\nimport { planRouter } from './routers/plan.js';\nimport { subscriptionRouter } from './routers/subscription.js';\nimport { router } from './trpc.js';\n\nexport const appRouter = router({\n  hook: hookRouter,\n  plan: planRouter,\n  subscription: subscriptionRouter,\n  conversation: conversationRouter,\n});\n\nexport type AppRouter = typeof appRouter;\n\nexport type { Context, CreateContextFn, Logger, PlanStore } from './context.js';\nexport type { ConversationContext, ConversationHandlers } from './routers/conversation.js';\nexport { conversationRouter } from './routers/conversation.js';\nexport type {\n  ApprovalResult,\n  HookContext,\n  HookHandlers,\n  SessionContextResult,\n} from './routers/hook.js';\nexport { hookRouter } from './routers/hook.js';\nexport { planRouter } from './routers/plan.js';\nexport { subscriptionRouter } from './routers/subscription.js';\nexport type {\n  Change,\n  ChangesResponse,\n  ChangeType,\n  DeleteSubscriptionResponse,\n  HasConnectionsResponse,\n  ImportConversationRequest,\n  ImportConversationResponse,\n  PlanIdInput,\n  PlanStatusResponse,\n  SetSessionTokenRequest,\n  SetSessionTokenResponse,\n  SubscriptionClientIdInput,\n  SubscriptionCreateParams,\n} from './schemas.js';\n\nexport {\n  ChangeSchema,\n  ChangesResponseSchema,\n  ChangeTypeSchema,\n  DeleteSubscriptionResponseSchema,\n  HasConnectionsResponseSchema,\n  ImportConversationRequestSchema,\n  ImportConversationResponseSchema,\n  PlanIdSchema,\n  PlanStatusResponseSchema,\n  SetSessionTokenRequestSchema,\n  SetSessionTokenResponseSchema,\n  SubscriptionClientIdSchema,\n} from './schemas.js';\n\n/*\n * NOTE: middleware, publicProcedure, and router are NOT exported here\n * to prevent bundling @trpc/server in browser builds.\n * Server code should import these directly from './trpc.js' if needed.\n */\n","import type * as Y from 'yjs';\n\n/**\n * User profile stored in the Y.Doc users map.\n */\nexport interface UserProfile {\n  displayName: string;\n  color: string;\n}\n\n/**\n * Create a user resolver function bound to a specific Y.Doc.\n * Useful when resolving multiple users in a loop.\n *\n * @param ydoc - Y.Doc containing the users map\n * @param fallbackLength - Length of userId to use as fallback (default: 8)\n * @returns Function that resolves user IDs to display names\n */\nexport function createUserResolver(ydoc: Y.Doc, fallbackLength = 8): (userId: string) => string {\n  const usersMap = ydoc.getMap<UserProfile>('users');\n\n  return (userId: string): string => {\n    const userData = usersMap.get(userId);\n    return userData?.displayName ?? userId.slice(0, fallbackLength);\n  };\n}\n"],"mappings":"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"}