{"version":3,"file":"yjs-helpers-Da2r3318.mjs","names":[],"sources":["../src/assert-never.ts","../src/hook-api.ts","../src/input-request.ts","../src/yjs-keys.ts","../src/thread.ts","../src/yjs-helpers.ts"],"sourcesContent":["/**\n * Exhaustive type checking helper.\n * Ensures all cases of a discriminated union are handled.\n *\n * Usage:\n * ```typescript\n * switch (value.type) {\n *   case 'a': return handleA();\n *   case 'b': return handleB();\n *   default: return assertNever(value);\n * }\n * ```\n *\n * When a new union member is added, TypeScript will fail at compile time\n * if not all cases are handled in the switch statement.\n */\nexport function assertNever(value: never): never {\n  throw new Error(`Unhandled discriminated union member: ${JSON.stringify(value)}`);\n}\n","/**\n * Shared schemas for hook ↔ server HTTP API communication.\n * These types are used by both @shipyard/hook and @shipyard/server.\n */\n\nimport { z } from 'zod';\n\n/**\n * Tracks an agent's presence in a plan session.\n */\nexport const AgentPresenceSchema = z.object({\n  /** Type of agent (for display purposes) */\n  agentType: z.string(),\n  /** Unique session identifier */\n  sessionId: z.string(),\n  /** When the agent connected (unix timestamp ms) */\n  connectedAt: z.number(),\n  /** Last activity timestamp (unix timestamp ms) */\n  lastSeenAt: z.number(),\n});\n\nexport type AgentPresence = z.infer<typeof AgentPresenceSchema>;\n\n/**\n * A single comment in a review thread.\n */\nexport const ReviewCommentSchema = z.object({\n  author: z.string(),\n  content: z.string(),\n  createdAt: z.number(),\n});\n\nexport type ReviewComment = z.infer<typeof ReviewCommentSchema>;\n\n/**\n * Review feedback for a specific block in the plan.\n */\nexport const ReviewFeedbackSchema = z.object({\n  threadId: z.string(),\n  blockId: z.string().optional(),\n  comments: z.array(ReviewCommentSchema),\n});\n\nexport type ReviewFeedback = z.infer<typeof ReviewFeedbackSchema>;\n\n/**\n * POST /api/hook/session - Create a new plan session\n */\nexport const CreateHookSessionRequestSchema = z.object({\n  sessionId: z.string(),\n  agentType: z.string().default('claude-code'),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n});\n\nexport type CreateHookSessionRequest = z.infer<typeof CreateHookSessionRequestSchema>;\n\nexport const CreateHookSessionResponseSchema = z.object({\n  planId: z.string(),\n  url: z.string(),\n});\n\nexport type CreateHookSessionResponse = z.infer<typeof CreateHookSessionResponseSchema>;\n\n/**\n * PUT /api/hook/plan/:id/content - Update plan content\n */\nexport const UpdatePlanContentRequestSchema = z.object({\n  content: z.string(),\n  /** Optional file path for tracking which file is being synced */\n  filePath: z.string().optional(),\n});\n\nexport type UpdatePlanContentRequest = z.infer<typeof UpdatePlanContentRequestSchema>;\n\nexport const UpdatePlanContentResponseSchema = z.object({\n  success: z.boolean(),\n  updatedAt: z.number(),\n});\n\nexport type UpdatePlanContentResponse = z.infer<typeof UpdatePlanContentResponseSchema>;\n\n/**\n * GET /api/hook/plan/:id/review - Get review status\n * Uses discriminated union to match PlanMetadata structure\n */\nexport const GetReviewStatusResponseSchema = z.discriminatedUnion('status', [\n  z.object({\n    status: z.literal('draft'),\n  }),\n  z.object({\n    status: z.literal('pending_review'),\n    reviewRequestId: z.string(),\n  }),\n  z.object({\n    status: z.literal('changes_requested'),\n    reviewedAt: z.number(),\n    reviewedBy: z.string(),\n    reviewComment: z.string().optional(),\n    feedback: z.array(ReviewFeedbackSchema).optional(),\n  }),\n  z.object({\n    status: z.literal('in_progress'),\n    reviewedAt: z.number(),\n    reviewedBy: z.string(),\n  }),\n  z.object({\n    status: z.literal('completed'),\n    completedAt: z.number(),\n    completedBy: z.string(),\n    snapshotUrl: z.string().optional(),\n  }),\n]);\n\nexport type GetReviewStatusResponse = z.infer<typeof GetReviewStatusResponseSchema>;\n\n/**\n * POST /api/hook/plan/:id/presence - Update agent presence\n */\nexport const UpdatePresenceRequestSchema = z.object({\n  agentType: z.string(),\n  sessionId: z.string(),\n});\n\nexport type UpdatePresenceRequest = z.infer<typeof UpdatePresenceRequestSchema>;\n\nexport const UpdatePresenceResponseSchema = z.object({\n  success: z.boolean(),\n});\n\nexport type UpdatePresenceResponse = z.infer<typeof UpdatePresenceResponseSchema>;\n\n/**\n * Error response from hook API\n */\nexport const HookApiErrorSchema = z.object({\n  error: z.string(),\n});\n\nexport type HookApiError = z.infer<typeof HookApiErrorSchema>;\n\n/**\n * POST /register - Register a WebSocket server\n */\nexport const RegisterServerRequestSchema = z.object({\n  port: z.number().int().positive(),\n  pid: z.number().int().positive(),\n});\n\nexport type RegisterServerRequest = z.infer<typeof RegisterServerRequestSchema>;\n\nexport const RegisterServerResponseSchema = z.object({\n  success: z.boolean(),\n  entry: z.object({\n    port: z.number(),\n    pid: z.number(),\n    url: z.string(),\n    registeredAt: z.number(),\n  }),\n});\n\nexport type RegisterServerResponse = z.infer<typeof RegisterServerResponseSchema>;\n\n/**\n * DELETE /unregister - Unregister a WebSocket server\n */\nexport const UnregisterServerRequestSchema = z.object({\n  pid: z.number().int().positive(),\n});\n\nexport type UnregisterServerRequest = z.infer<typeof UnregisterServerRequestSchema>;\n\nexport const UnregisterServerResponseSchema = z.object({\n  success: z.boolean(),\n  existed: z.boolean(),\n});\n\nexport type UnregisterServerResponse = z.infer<typeof UnregisterServerResponseSchema>;\n\n/**\n * POST /api/plan/:id/subscribe - Create a subscription\n */\nexport const CreateSubscriptionRequestSchema = z.object({\n  subscribe: z.array(z.string()).optional(),\n  windowMs: z.number().positive().optional(),\n  maxWindowMs: z.number().positive().optional(),\n  threshold: z.number().positive().optional(),\n});\n\nexport type CreateSubscriptionRequest = z.infer<typeof CreateSubscriptionRequestSchema>;\n\nexport const CreateSubscriptionResponseSchema = z.object({\n  clientId: z.string(),\n});\n\nexport type CreateSubscriptionResponse = z.infer<typeof CreateSubscriptionResponseSchema>;\n","import { nanoid } from 'nanoid';\nimport { z } from 'zod';\n\n/**\n * Valid input request types.\n * - text: Single-line text input\n * - multiline: Multi-line text input\n * - choice: Select from predefined options\n * - confirm: Boolean yes/no question\n */\nexport const InputRequestTypeValues = ['text', 'multiline', 'choice', 'confirm'] as const;\nexport type InputRequestType = (typeof InputRequestTypeValues)[number];\n\n/**\n * Valid status values for an input request.\n * - pending: Awaiting user response\n * - answered: User has responded\n * - declined: User explicitly declined to answer\n * - cancelled: Request cancelled (timeout)\n */\nexport const InputRequestStatusValues = ['pending', 'answered', 'declined', 'cancelled'] as const;\nexport type InputRequestStatus = (typeof InputRequestStatusValues)[number];\n\nconst InputRequestBaseSchema = z.object({\n  /** Unique request ID */\n  id: z.string(),\n  /** When the request was created (Unix timestamp in ms) */\n  createdAt: z.number(),\n  /** Prompt message shown to the user */\n  message: z.string().min(1, 'Message cannot be empty'),\n  /** Current status of the request */\n  status: z.enum(InputRequestStatusValues),\n  /** Default value to pre-populate the input */\n  defaultValue: z.string().optional(),\n  /** Timeout in seconds (0 = no timeout) */\n  timeout: z\n    .number()\n    .int()\n    .min(10, 'Timeout must be at least 10 seconds')\n    .max(600, 'Timeout cannot exceed 10 minutes')\n    .optional(),\n  /** Optional plan ID to associate request with a specific plan (null/undefined = global) */\n  planId: z.string().optional(),\n  /** User's response (any JSON-serializable value) */\n  response: z.unknown().optional(),\n  /** When the user answered (Unix timestamp in ms) */\n  answeredAt: z.number().optional(),\n  /** Who answered (username or \"agent\") */\n  answeredBy: z.string().optional(),\n});\n\n/** Text input request - single line text entry */\nconst TextInputSchema = InputRequestBaseSchema.extend({\n  type: z.literal('text'),\n});\n\n/** Multiline input request - multi-line text entry */\nconst MultilineInputSchema = InputRequestBaseSchema.extend({\n  type: z.literal('multiline'),\n});\n\n/** Choice input request - select from predefined options */\nconst ChoiceInputSchema = InputRequestBaseSchema.extend({\n  type: z.literal('choice'),\n  /** Available options - REQUIRED for choice type */\n  options: z.array(z.string()).min(1, 'Choice requests must have at least one option'),\n  /** Enable multi-select for 'choice' type (uses checkboxes instead of radio buttons) */\n  multiSelect: z.boolean().optional(),\n});\n\n/** Confirm input request - boolean yes/no question */\nconst ConfirmInputSchema = InputRequestBaseSchema.extend({\n  type: z.literal('confirm'),\n});\n\n/**\n * Schema for an input request stored in Y.Doc.\n * Uses discriminated union on 'type' field to ensure:\n * - 'choice' type REQUIRES options array\n * - Other types don't have options\n *\n * Follows CRDT patterns from existing Shipyard schemas.\n */\nexport const InputRequestSchema = z.discriminatedUnion('type', [\n  TextInputSchema,\n  MultilineInputSchema,\n  ChoiceInputSchema,\n  ConfirmInputSchema,\n]);\n\nexport type InputRequest = z.infer<typeof InputRequestSchema>;\n\nexport type TextInputRequest = z.infer<typeof TextInputSchema>;\nexport type MultilineInputRequest = z.infer<typeof MultilineInputSchema>;\nexport type ChoiceInputRequest = z.infer<typeof ChoiceInputSchema>;\nexport type ConfirmInputRequest = z.infer<typeof ConfirmInputSchema>;\n\n/** Base params for creating any input request */\ninterface CreateInputRequestBaseParams {\n  message: string;\n  defaultValue?: string;\n  timeout?: number;\n  planId?: string;\n}\n\n/** Params for creating a text input request */\nexport interface CreateTextInputParams extends CreateInputRequestBaseParams {\n  type: 'text';\n}\n\n/** Params for creating a multiline input request */\nexport interface CreateMultilineInputParams extends CreateInputRequestBaseParams {\n  type: 'multiline';\n}\n\n/** Params for creating a choice input request */\nexport interface CreateChoiceInputParams extends CreateInputRequestBaseParams {\n  type: 'choice';\n  /** Required: available options for selection */\n  options: string[];\n  /** Enable multi-select (uses checkboxes instead of radio buttons) */\n  multiSelect?: boolean;\n}\n\n/** Params for creating a confirm input request */\nexport interface CreateConfirmInputParams extends CreateInputRequestBaseParams {\n  type: 'confirm';\n}\n\n/**\n * Parameters for creating a new input request.\n * Discriminated union ensures 'choice' type requires options.\n */\nexport type CreateInputRequestParams =\n  | CreateTextInputParams\n  | CreateMultilineInputParams\n  | CreateChoiceInputParams\n  | CreateConfirmInputParams;\n\n/**\n * Create a new input request with auto-generated fields.\n * Sets id, createdAt, and status to initial values.\n *\n * @param params - Request parameters (discriminated by type)\n * @returns Complete InputRequest ready to store in Y.Doc\n */\nexport function createInputRequest(params: CreateInputRequestParams): InputRequest {\n  const baseFields = {\n    id: nanoid(),\n    createdAt: Date.now(),\n    message: params.message,\n    defaultValue: params.defaultValue,\n    status: 'pending' as const,\n    timeout: params.timeout,\n    planId: params.planId,\n  };\n\n  let request: unknown;\n\n  switch (params.type) {\n    case 'text':\n      request = { ...baseFields, type: 'text' as const };\n      break;\n    case 'multiline':\n      request = { ...baseFields, type: 'multiline' as const };\n      break;\n    case 'choice':\n      request = {\n        ...baseFields,\n        type: 'choice' as const,\n        options: params.options,\n        multiSelect: params.multiSelect,\n      };\n      break;\n    case 'confirm':\n      request = { ...baseFields, type: 'confirm' as const };\n      break;\n  }\n\n  const parseResult = InputRequestSchema.safeParse(request);\n  if (!parseResult.success) {\n    throw new Error(`Invalid input request: ${parseResult.error.issues[0]?.message}`);\n  }\n\n  return parseResult.data;\n}\n","/**\n * Shared Y.Doc key constants to prevent typos and mismatches.\n *\n * CRITICAL: These keys define the structure of the Y.Doc CRDT.\n * All parts of the codebase (server, web, tests) MUST use these constants\n * to ensure data is written to and read from the same locations.\n *\n * @see docs/yjs-data-model.md for detailed explanation of each key\n */\n\n/**\n * Y.Doc keys used across the application.\n * Using `as const` makes these literal types for better type safety.\n */\nexport const YDOC_KEYS = {\n  /**\n   * Plan metadata (Y.Map<string, unknown>)\n   * Contains: id, title, status, createdAt, updatedAt, reviewedAt, reviewedBy, repo, pr\n   *\n   * Used by:\n   * - Server: packages/server/src/tools/create-plan.ts (write)\n   * - Web: packages/web/src/pages/PlanPage.tsx (read)\n   * - Web: packages/web/src/hooks/useHydration.ts (write)\n   * - Web: packages/web/src/components/ReviewActions.tsx (write)\n   * - Helpers: packages/schema/src/yjs-helpers.ts (read/write)\n   */\n  METADATA: 'metadata' as const,\n\n  /**\n   * BlockNote document (Y.XmlFragment) - SOURCE OF TRUTH for plan content\n   * Used for: Real-time collaborative editing, read_plan tool, all content operations\n   *\n   * CRITICAL: BlockNote expects this to be an XmlFragment, NOT an Array!\n   * This is the authoritative source for all plan content.\n   *\n   * Used by:\n   * - Server: apps/server/src/tools/create-plan.ts (write via blocksToYXmlFragment)\n   * - Server: apps/server/src/export-markdown.ts (read via yXmlFragmentToBlocks)\n   * - Web: apps/web/src/components/PlanViewer.tsx (BlockNote collaboration)\n   * - Web: apps/web/src/hooks/useHydration.ts (write from URL snapshot)\n   */\n  DOCUMENT_FRAGMENT: 'document' as const,\n\n  /**\n   * Comment threads (Y.Map<string, Thread>)\n   * Managed by BlockNote's YjsThreadStore\n   *\n   * Structure: Map of thread ID → Thread object with comments array\n   *\n   * Used by:\n   * - Web: packages/web/src/components/PlanViewer.tsx (YjsThreadStore initialization)\n   * - Web: packages/web/src/components/CommentsPanel.tsx (read)\n   * - Server: packages/server/src/tools/get-feedback.ts (read)\n   */\n  THREADS: 'threads' as const,\n\n  /**\n   * Step completion status (Y.Map<string, boolean>)\n   * Maps step ID → completion status\n   *\n   * Used by:\n   * - Helpers: packages/schema/src/yjs-helpers.ts (read/write)\n   */\n  STEP_COMPLETIONS: 'stepCompletions' as const,\n\n  /**\n   * Plan index (Y.Map<string, PlanIndexEntry>)\n   * Only used in the special PLAN_INDEX_DOC_NAME document\n   * Maps plan ID → index entry (title, status, timestamps)\n   *\n   * Used by:\n   * - Web: packages/web/src/hooks/usePlanIndex.ts (read)\n   * - Helpers: packages/schema/src/plan-index-helpers.ts (read/write)\n   */\n  PLANS: 'plans' as const,\n\n  /**\n   * Artifact references (Y.Array<Artifact>)\n   * Contains: id, type, filename, url\n   * Binary content lives in GitHub orphan branch, not in CRDT\n   *\n   * Used by:\n   * - Server: apps/server/src/tools/add-artifact.ts (write)\n   * - Web: apps/web/src/components/Attachments.tsx (read)\n   * - Helpers: packages/schema/src/yjs-helpers.ts (read/write)\n   */\n  ARTIFACTS: 'artifacts' as const,\n\n  /**\n   * Deliverables extracted from plan (Y.Array<Deliverable>)\n   * Contains checkboxes marked with {#deliverable} tag\n   * Linked to artifacts when agent uploads proof\n   *\n   * Used by:\n   * - Server: apps/server/src/tools/create-plan.ts (write)\n   * - Server: apps/server/src/tools/add-artifact.ts (update on link)\n   * - Web: apps/web/src/components/DeliverablesView.tsx (read)\n   * - Helpers: packages/schema/src/yjs-helpers.ts (read/write)\n   */\n  DELIVERABLES: 'deliverables' as const,\n\n  /**\n   * Agent presence (Y.Map<string, AgentPresence>)\n   * Maps session ID → presence info (agentType, connectedAt, lastSeenAt)\n   * Used for real-time \"Claude is here\" indicator\n   *\n   * Used by:\n   * - Server: apps/server/src/registry-server.ts (write via hook API)\n   * - Web: apps/web/src/components/PresenceIndicator.tsx (read)\n   * - Helpers: packages/schema/src/yjs-helpers.ts (read/write)\n   */\n  PRESENCE: 'presence' as const,\n\n  /**\n   * Linked PRs (Y.Array<LinkedPR>)\n   * Contains GitHub PRs linked to this plan\n   * Auto-populated by complete_task when it detects a PR on the current branch\n   *\n   * Used by:\n   * - Server: apps/server/src/tools/complete-task.ts (write on auto-link)\n   * - Web: apps/web/src/components/ChangesView.tsx (read)\n   * - Helpers: packages/schema/src/yjs-helpers.ts (read/write)\n   */\n  LINKED_PRS: 'linkedPRs' as const,\n\n  /**\n   * PR Review Comments (Y.Array<PRReviewComment>)\n   * Contains review comments on PR diffs\n   * Can be added by AI (via MCP tool) or humans (via UI)\n   *\n   * Used by:\n   * - Server: apps/server/src/tools/add-pr-review-comment.ts (write)\n   * - Web: apps/web/src/components/MonacoDiffViewer.tsx (read/write)\n   * - Helpers: packages/schema/src/yjs-helpers.ts (read/write)\n   */\n  PR_REVIEW_COMMENTS: 'prReviewComments' as const,\n\n  /**\n   * Plan events (Y.Array<PlanEvent>)\n   * Contains timeline events for audit trail and activity display\n   * Events include: plan_created, status_changed, approved, etc.\n   *\n   * Used by:\n   * - Server: apps/server/src/tools/*.ts (write on actions)\n   * - Web: apps/web/src/components/Timeline.tsx (read)\n   */\n  EVENTS: 'events' as const,\n\n  /**\n   * Plan snapshots (Y.Array<PlanSnapshot>)\n   * Contains version history snapshots taken at significant status changes.\n   * Each snapshot captures content, threads summary, artifacts, and deliverables.\n   * Synced via CRDT to all peers.\n   *\n   * Used by:\n   * - Server: apps/server/src/tools/*.ts (write on status changes)\n   * - Web: apps/web/src/components/VersionHistory.tsx (read)\n   * - Web: apps/web/src/hooks/useSnapshots.ts (read)\n   * - Helpers: packages/schema/src/yjs-helpers.ts (read/write)\n   */\n  SNAPSHOTS: 'snapshots' as const,\n\n  /**\n   * User input requests (Y.Array<InputRequest>)\n   * Contains requests for user input from MCP tools or Hook API.\n   * Allows blocking until user provides a response in the browser UI.\n   *\n   * Used by:\n   * - Server: apps/server/src/services/input-request-manager.ts (read/write)\n   * - Server: apps/server/src/tools/request-user-input.ts (create requests)\n   * - Web: apps/web/src/components/InputRequestDialog.tsx (read/write responses)\n   */\n  INPUT_REQUESTS: 'inputRequests' as const,\n} as const;\n\n/**\n * Type-safe accessor for Y.Doc keys.\n * This ensures we can't accidentally use a wrong key.\n */\nexport type YDocKey = (typeof YDOC_KEYS)[keyof typeof YDOC_KEYS];\n\n/**\n * Helper to validate a key is one of the known Y.Doc keys.\n * Useful for runtime validation when keys come from external sources.\n */\nexport function isValidYDocKey(key: string): key is YDocKey {\n  return Object.values(YDOC_KEYS).includes(key as YDocKey);\n}\n","import { z } from 'zod';\n\n/**\n * Zod schema for comment body - can be a string or structured content.\n * BlockNote stores comment bodies as arrays of block content.\n */\nexport const CommentBodySchema = z.union([z.string(), z.array(z.unknown())]);\n\n/**\n * BlockNote comment content - can be a string or structured content.\n * Schema is source of truth - type derived via z.infer.\n */\nexport type CommentBody = z.infer<typeof CommentBodySchema>;\n\n/**\n * Zod schema for thread comment validation.\n */\nexport const ThreadCommentSchema = z.object({\n  id: z.string(),\n  userId: z.string(),\n  body: CommentBodySchema,\n  createdAt: z.number(),\n});\n\n/**\n * Individual comment within a thread.\n * Schema is source of truth - type derived via z.infer.\n */\nexport type ThreadComment = z.infer<typeof ThreadCommentSchema>;\n\n/**\n * Zod schema for thread validation.\n */\nexport const ThreadSchema = z.object({\n  id: z.string(),\n  comments: z.array(ThreadCommentSchema),\n  resolved: z.boolean().optional(),\n  selectedText: z.string().optional(),\n});\n\n/**\n * Comment thread on a plan block.\n * Schema is source of truth - type derived via z.infer.\n */\nexport type Thread = z.infer<typeof ThreadSchema>;\n\n/**\n * Type guard for checking if a value is a valid Thread.\n */\nexport function isThread(value: unknown): value is Thread {\n  return ThreadSchema.safeParse(value).success;\n}\n\n/**\n * Safely parse threads from Y.Map data.\n * Returns only valid threads, silently dropping invalid ones.\n */\nexport function parseThreads(data: Record<string, unknown>): Thread[] {\n  const threads: Thread[] = [];\n  for (const [_key, value] of Object.entries(data)) {\n    const result = ThreadSchema.safeParse(value);\n    if (result.success) {\n      threads.push(result.data);\n    }\n  }\n  return threads;\n}\n\n/**\n * Extract plain text from BlockNote comment body.\n * Handles both string and structured block content.\n */\nexport function extractTextFromCommentBody(body: CommentBody): string {\n  if (typeof body === 'string') {\n    return body;\n  }\n\n  if (!Array.isArray(body)) {\n    return '';\n  }\n\n  return body\n    .map((block) => {\n      if (typeof block === 'string') return block;\n      if (typeof block !== 'object' || block === null) return '';\n\n      const blockObj = block as { content?: unknown };\n      if (Array.isArray(blockObj.content)) {\n        return blockObj.content\n          .map((item: unknown) => {\n            if (typeof item === 'string') return item;\n            if (typeof item === 'object' && item !== null && 'text' in item) {\n              return (item as { text: string }).text;\n            }\n            return '';\n          })\n          .join('');\n      }\n\n      return '';\n    })\n    .join('\\n');\n}\n\n/**\n * Extract @mentions from comment body.\n * Looks for patterns like @username in the text.\n *\n * @param body - Comment body (string or structured content)\n * @returns Array of mentioned GitHub usernames (without @ prefix)\n */\nexport function extractMentions(body: CommentBody): string[] {\n  const text = extractTextFromCommentBody(body);\n  const mentionRegex = /@([a-zA-Z0-9_-]+)/g;\n  const mentions: string[] = [];\n  let match: RegExpExecArray | null;\n\n  // biome-ignore lint/suspicious/noAssignInExpressions: Standard regex exec loop pattern\n  while ((match = mentionRegex.exec(text)) !== null) {\n    if (match[1]) {\n      mentions.push(match[1]);\n    }\n  }\n\n  return [...new Set(mentions)];\n}\n","import { nanoid } from 'nanoid';\nimport * as Y from 'yjs';\nimport { assertNever } from './assert-never.js';\nimport { type AgentPresence, AgentPresenceSchema } from './hook-api.js';\nimport { type InputRequest, InputRequestSchema } from './input-request.js';\nimport {\n  type Artifact,\n  ArtifactSchema,\n  type ConversationVersion,\n  ConversationVersionSchema,\n  type Deliverable,\n  DeliverableSchema,\n  type LinkedPR,\n  LinkedPRSchema,\n  type OriginMetadata,\n  type PlanEvent,\n  PlanEventSchema,\n  type PlanEventType,\n  type PlanMetadata,\n  PlanMetadataSchema,\n  type PlanSnapshot,\n  PlanSnapshotSchema,\n  type PlanStatusType,\n  type PRReviewComment,\n  PRReviewCommentSchema,\n} from './plan.js';\nimport { parseThreads } from './thread.js';\nimport { YDOC_KEYS } from './yjs-keys.js';\n\n/**\n * Fields that can be safely updated without changing status.\n * These are the common base fields that don't have invariants with status.\n */\nexport interface PlanMetadataBaseUpdate {\n  title?: string;\n  repo?: string;\n  pr?: number;\n  ownerId?: string;\n  approvalRequired?: boolean;\n  approvedUsers?: string[];\n  rejectedUsers?: string[];\n  sessionTokenHash?: string;\n  archivedAt?: number;\n  archivedBy?: string;\n  origin?: OriginMetadata;\n  viewedBy?: Record<string, number>;\n  conversationVersions?: ConversationVersion[];\n  events?: PlanEvent[];\n  tags?: string[];\n}\n\n/**\n * Valid status transitions in the plan lifecycle.\n *\n * Flow: draft -> (pending_review | in_progress) <-> changes_requested -> in_progress -> completed\n *\n * Plans can go directly from draft to in_progress if approval is not required.\n * Plans requiring approval must go through: draft -> pending_review -> in_progress.\n *\n * Each transition requires specific fields to be provided.\n */\nexport const VALID_STATUS_TRANSITIONS: Record<PlanStatusType, PlanStatusType[]> = {\n  draft: ['pending_review', 'in_progress'],\n  pending_review: ['in_progress', 'changes_requested'],\n  changes_requested: ['pending_review', 'in_progress'],\n  in_progress: ['completed'],\n  completed: [],\n};\n\n/**\n * Type for transitioning to pending_review status.\n */\nexport interface TransitionToPendingReview {\n  status: 'pending_review';\n  reviewRequestId: string;\n}\n\n/**\n * Type for transitioning to changes_requested status.\n */\nexport interface TransitionToChangesRequested {\n  status: 'changes_requested';\n  reviewedAt: number;\n  reviewedBy: string;\n  reviewComment?: string;\n}\n\n/**\n * Type for transitioning to in_progress status.\n * When coming from pending_review, requires review fields.\n * When coming from draft (no approval required), review fields are optional.\n */\nexport interface TransitionToInProgress {\n  status: 'in_progress';\n  reviewedAt?: number;\n  reviewedBy?: string;\n  reviewComment?: string;\n}\n\n/**\n * Type for transitioning to completed status.\n */\nexport interface TransitionToCompleted {\n  status: 'completed';\n  completedAt: number;\n  completedBy: string;\n  snapshotUrl?: string;\n}\n\n/**\n * Union of all valid status transitions.\n */\nexport type StatusTransition =\n  | TransitionToPendingReview\n  | TransitionToChangesRequested\n  | TransitionToInProgress\n  | TransitionToCompleted;\n\n/**\n * Result type for status transition operations.\n */\nexport type TransitionResult = { success: true } | { success: false; error: string };\n\n/**\n * Result type for getPlanMetadata with validation errors.\n */\nexport type GetPlanMetadataResult =\n  | { success: true; data: PlanMetadata }\n  | { success: false; error: string };\n\n/**\n * Get plan metadata from Y.Doc with validation.\n * @returns PlanMetadata if valid, null if data is missing or invalid.\n * @deprecated Use getPlanMetadataWithValidation for error details.\n */\nexport function getPlanMetadata(ydoc: Y.Doc): PlanMetadata | null {\n  const result = getPlanMetadataWithValidation(ydoc);\n  return result.success ? result.data : null;\n}\n\n/**\n * Get plan metadata from Y.Doc with detailed validation errors.\n * Surfaces corruption errors instead of silently swallowing them.\n */\nexport function getPlanMetadataWithValidation(ydoc: Y.Doc): GetPlanMetadataResult {\n  const map = ydoc.getMap(YDOC_KEYS.METADATA);\n  const data = map.toJSON();\n\n  if (!data || Object.keys(data).length === 0) {\n    return { success: false, error: 'No metadata found in Y.Doc' };\n  }\n\n  const result = PlanMetadataSchema.safeParse(data);\n  if (!result.success) {\n    return { success: false, error: `Invalid metadata: ${result.error.message}` };\n  }\n\n  return { success: true, data: result.data };\n}\n\n/**\n * Update plan metadata base fields (non-status fields).\n * Use transitionPlanStatus() for status changes.\n *\n * This function only allows updating fields that don't have status invariants.\n * Status changes must go through transitionPlanStatus() to ensure valid transitions.\n */\nexport function setPlanMetadata(\n  ydoc: Y.Doc,\n  metadata: PlanMetadataBaseUpdate,\n  actor?: string\n): void {\n  ydoc.transact(\n    () => {\n      const map = ydoc.getMap(YDOC_KEYS.METADATA);\n\n      for (const [key, value] of Object.entries(metadata)) {\n        if (value !== undefined) {\n          map.set(key, value);\n        }\n      }\n\n      map.set('updatedAt', Date.now());\n    },\n    actor ? { actor } : undefined\n  );\n}\n\n/**\n * Apply pending_review transition fields to metadata map.\n */\nfunction applyPendingReviewTransition(\n  map: Y.Map<unknown>,\n  transition: TransitionToPendingReview\n): void {\n  map.set('reviewRequestId', transition.reviewRequestId);\n}\n\n/**\n * Apply changes_requested transition fields to metadata map.\n */\nfunction applyChangesRequestedTransition(\n  map: Y.Map<unknown>,\n  transition: TransitionToChangesRequested\n): void {\n  map.set('reviewedAt', transition.reviewedAt);\n  map.set('reviewedBy', transition.reviewedBy);\n  if (transition.reviewComment !== undefined) {\n    map.set('reviewComment', transition.reviewComment);\n  }\n}\n\n/**\n * Apply in_progress transition fields to metadata map.\n */\nfunction applyInProgressTransition(map: Y.Map<unknown>, transition: TransitionToInProgress): void {\n  if (transition.reviewedAt !== undefined) {\n    map.set('reviewedAt', transition.reviewedAt);\n  }\n  if (transition.reviewedBy !== undefined) {\n    map.set('reviewedBy', transition.reviewedBy);\n  }\n  if (transition.reviewComment !== undefined) {\n    map.set('reviewComment', transition.reviewComment);\n  }\n}\n\n/**\n * Apply completed transition fields to metadata map.\n */\nfunction applyCompletedTransition(map: Y.Map<unknown>, transition: TransitionToCompleted): void {\n  map.set('completedAt', transition.completedAt);\n  map.set('completedBy', transition.completedBy);\n  if (transition.snapshotUrl !== undefined) {\n    map.set('snapshotUrl', transition.snapshotUrl);\n  }\n}\n\n/**\n * Apply status-specific transition fields to metadata map.\n */\nfunction applyStatusTransitionFields(map: Y.Map<unknown>, transition: StatusTransition): void {\n  switch (transition.status) {\n    case 'pending_review':\n      applyPendingReviewTransition(map, transition);\n      break;\n    case 'changes_requested':\n      applyChangesRequestedTransition(map, transition);\n      break;\n    case 'in_progress':\n      applyInProgressTransition(map, transition);\n      break;\n    case 'completed':\n      applyCompletedTransition(map, transition);\n      break;\n    default:\n      assertNever(transition);\n  }\n}\n\n/**\n * Transition plan status with state machine validation.\n * Enforces valid status transitions and ensures required fields are provided.\n *\n * Valid transitions:\n * - draft -> pending_review (requires reviewRequestId)\n * - pending_review -> in_progress (requires reviewedAt, reviewedBy)\n * - pending_review -> changes_requested (requires reviewedAt, reviewedBy, optional reviewComment)\n * - changes_requested -> pending_review (requires reviewRequestId)\n * - in_progress -> completed (requires completedAt, completedBy, optional snapshotUrl)\n */\nexport function transitionPlanStatus(\n  ydoc: Y.Doc,\n  transition: StatusTransition,\n  actor?: string\n): TransitionResult {\n  const metadataResult = getPlanMetadataWithValidation(ydoc);\n  if (!metadataResult.success) {\n    return { success: false, error: metadataResult.error };\n  }\n\n  const currentStatus = metadataResult.data.status;\n  const validTargets = VALID_STATUS_TRANSITIONS[currentStatus];\n\n  if (!validTargets.includes(transition.status)) {\n    return {\n      success: false,\n      error: `Invalid transition: cannot go from '${currentStatus}' to '${transition.status}'. Valid targets: ${validTargets.join(', ') || 'none (terminal state)'}`,\n    };\n  }\n\n  ydoc.transact(\n    () => {\n      const map = ydoc.getMap(YDOC_KEYS.METADATA);\n      map.set('status', transition.status);\n      applyStatusTransitionFields(map, transition);\n      map.set('updatedAt', Date.now());\n    },\n    actor ? { actor } : undefined\n  );\n\n  return { success: true };\n}\n\n/**\n * Initialize plan metadata for a new draft plan.\n * Only creates plans in 'draft' status - use transitionPlanStatus() to change status.\n *\n * Note: This function is intentionally restricted to draft status.\n * Other statuses require specific fields (reviewRequestId for pending_review, etc.)\n * that should be set via transitionPlanStatus() for proper validation.\n */\nexport interface InitPlanMetadataParams {\n  id: string;\n  title: string;\n  repo?: string;\n  pr?: number;\n  ownerId?: string;\n  approvalRequired?: boolean;\n  sessionTokenHash?: string;\n  origin?: OriginMetadata;\n  tags?: string[];\n}\n\nexport function initPlanMetadata(ydoc: Y.Doc, init: InitPlanMetadataParams): void {\n  const map = ydoc.getMap(YDOC_KEYS.METADATA);\n  const now = Date.now();\n\n  map.set('id', init.id);\n  map.set('title', init.title);\n  map.set('status', 'draft');\n  map.set('createdAt', now);\n  map.set('updatedAt', now);\n\n  if (init.repo) map.set('repo', init.repo);\n  if (init.pr) map.set('pr', init.pr);\n\n  if (init.ownerId) {\n    map.set('ownerId', init.ownerId);\n    map.set('approvedUsers', [init.ownerId]);\n    map.set('approvalRequired', init.approvalRequired ?? true);\n  }\n\n  if (init.sessionTokenHash) {\n    map.set('sessionTokenHash', init.sessionTokenHash);\n  }\n\n  if (init.origin) {\n    map.set('origin', init.origin);\n  }\n\n  if (init.tags) {\n    map.set('tags', init.tags);\n  }\n\n  const result = getPlanMetadataWithValidation(ydoc);\n  if (!result.success) {\n    throw new Error(`Failed to initialize metadata: ${result.error}`);\n  }\n}\n\nexport function getStepCompletions(ydoc: Y.Doc): Map<string, boolean> {\n  const steps = ydoc.getMap<boolean>('stepCompletions');\n  return new Map(steps.entries());\n}\n\nexport function toggleStepCompletion(ydoc: Y.Doc, stepId: string, actor?: string): void {\n  ydoc.transact(\n    () => {\n      const steps = ydoc.getMap<boolean>('stepCompletions');\n      const current = steps.get(stepId) || false;\n      steps.set(stepId, !current);\n    },\n    actor ? { actor } : undefined\n  );\n}\n\nexport function isStepCompleted(ydoc: Y.Doc, stepId: string): boolean {\n  const steps = ydoc.getMap<boolean>('stepCompletions');\n  return steps.get(stepId) || false;\n}\n\nexport function getArtifacts(ydoc: Y.Doc): Artifact[] {\n  const array = ydoc.getArray<Artifact>(YDOC_KEYS.ARTIFACTS);\n  const data = array.toJSON() as unknown[];\n\n  return data\n    .map((item: unknown) => {\n      if (!item || typeof item !== 'object') {\n        return null;\n      }\n      const artifact = item as Record<string, unknown>;\n      if (artifact.url && !artifact.storage) {\n        return { ...artifact, storage: 'github' };\n      }\n      if (!artifact.storage && !artifact.url && !artifact.localArtifactId) {\n        return null;\n      }\n      return artifact;\n    })\n    .filter((item): item is Record<string, unknown> => item !== null)\n    .map((item) => ArtifactSchema.safeParse(item))\n    .filter((result) => result.success)\n    .map((result) => result.data);\n}\n\nexport function addArtifact(ydoc: Y.Doc, artifact: Artifact, actor?: string): void {\n  /*\n   * CRITICAL: Validate BEFORE transaction to prevent partial writes on validation failure.\n   * Validates discriminated union (storage: 'github' | 'local').\n   *\n   * Why validation-first pattern matters:\n   * - If validation throws inside transaction, Y.Doc may contain partial/corrupted state\n   * - Pre-validation ensures atomic all-or-nothing behavior\n   * - Failed validation returns clear error without touching Y.Doc\n   */\n  const validated = ArtifactSchema.parse(artifact);\n\n  ydoc.transact(\n    () => {\n      const array = ydoc.getArray<Artifact>(YDOC_KEYS.ARTIFACTS);\n      array.push([validated]);\n    },\n    actor ? { actor } : undefined\n  );\n}\n\nexport function removeArtifact(ydoc: Y.Doc, artifactId: string): boolean {\n  const array = ydoc.getArray<Artifact>(YDOC_KEYS.ARTIFACTS);\n  const artifacts = array.toJSON() as Artifact[];\n  const index = artifacts.findIndex((a) => a.id === artifactId);\n\n  if (index === -1) return false;\n\n  array.delete(index, 1);\n  return true;\n}\n\nexport function getAgentPresences(ydoc: Y.Doc): Map<string, AgentPresence> {\n  const map = ydoc.getMap<AgentPresence>(YDOC_KEYS.PRESENCE);\n  const result = new Map<string, AgentPresence>();\n\n  for (const [sessionId, value] of map.entries()) {\n    const parsed = AgentPresenceSchema.safeParse(value);\n    if (parsed.success) {\n      result.set(sessionId, parsed.data);\n    }\n  }\n\n  return result;\n}\n\nexport function setAgentPresence(ydoc: Y.Doc, presence: AgentPresence, actor?: string): void {\n  const validated = AgentPresenceSchema.parse(presence);\n\n  ydoc.transact(\n    () => {\n      const map = ydoc.getMap<AgentPresence>(YDOC_KEYS.PRESENCE);\n      map.set(validated.sessionId, validated);\n    },\n    actor ? { actor } : undefined\n  );\n}\n\nexport function clearAgentPresence(ydoc: Y.Doc, sessionId: string): boolean {\n  const map = ydoc.getMap<AgentPresence>(YDOC_KEYS.PRESENCE);\n  if (!map.has(sessionId)) return false;\n  map.delete(sessionId);\n  return true;\n}\n\nexport function getAgentPresence(ydoc: Y.Doc, sessionId: string): AgentPresence | null {\n  const map = ydoc.getMap<AgentPresence>(YDOC_KEYS.PRESENCE);\n  const value = map.get(sessionId);\n  if (!value) return null;\n\n  const parsed = AgentPresenceSchema.safeParse(value);\n  return parsed.success ? parsed.data : null;\n}\n\nexport function getDeliverables(ydoc: Y.Doc): Deliverable[] {\n  const array = ydoc.getArray<Deliverable>(YDOC_KEYS.DELIVERABLES);\n  const data = array.toJSON() as unknown[];\n\n  return data\n    .map((item) => DeliverableSchema.safeParse(item))\n    .filter((result) => result.success)\n    .map((result) => result.data);\n}\n\nexport function addDeliverable(ydoc: Y.Doc, deliverable: Deliverable, actor?: string): void {\n  const validated = DeliverableSchema.parse(deliverable);\n\n  ydoc.transact(\n    () => {\n      const array = ydoc.getArray<Deliverable>(YDOC_KEYS.DELIVERABLES);\n      array.push([validated]);\n    },\n    actor ? { actor } : undefined\n  );\n}\n\nexport function linkArtifactToDeliverable(\n  ydoc: Y.Doc,\n  deliverableId: string,\n  artifactId: string,\n  actor?: string\n): boolean {\n  const array = ydoc.getArray<Deliverable>(YDOC_KEYS.DELIVERABLES);\n  const deliverables = array.toJSON() as Deliverable[];\n  const index = deliverables.findIndex((d) => d.id === deliverableId);\n\n  if (index === -1) return false;\n\n  const existing = deliverables[index];\n  if (!existing) return false;\n\n  const updated: Deliverable = {\n    id: existing.id,\n    text: existing.text,\n    linkedArtifactId: artifactId,\n    linkedAt: Date.now(),\n  };\n\n  ydoc.transact(\n    () => {\n      array.delete(index, 1);\n      array.insert(index, [updated]);\n    },\n    actor ? { actor } : undefined\n  );\n\n  return true;\n}\n\nexport function getPlanOwnerId(ydoc: Y.Doc): string | null {\n  const map = ydoc.getMap(YDOC_KEYS.METADATA);\n  const ownerId = map.get('ownerId');\n  return typeof ownerId === 'string' ? ownerId : null;\n}\n\nexport function isApprovalRequired(ydoc: Y.Doc): boolean {\n  const map = ydoc.getMap(YDOC_KEYS.METADATA);\n  const approvalRequired = map.get('approvalRequired');\n  if (typeof approvalRequired === 'boolean') {\n    return approvalRequired;\n  }\n  const ownerId = map.get('ownerId');\n  return typeof ownerId === 'string' && ownerId.length > 0;\n}\n\nexport function getApprovedUsers(ydoc: Y.Doc): string[] {\n  const map = ydoc.getMap(YDOC_KEYS.METADATA);\n  const approvedUsers = map.get('approvedUsers');\n  if (!Array.isArray(approvedUsers)) {\n    return [];\n  }\n  return approvedUsers.filter((id): id is string => typeof id === 'string');\n}\n\nexport function isUserApproved(ydoc: Y.Doc, userId: string): boolean {\n  const ownerId = getPlanOwnerId(ydoc);\n  if (ownerId === userId) {\n    return true;\n  }\n  return getApprovedUsers(ydoc).includes(userId);\n}\n\nexport function approveUser(ydoc: Y.Doc, userId: string, actor?: string): void {\n  const currentApproved = getApprovedUsers(ydoc);\n  if (currentApproved.includes(userId)) {\n    return;\n  }\n\n  ydoc.transact(\n    () => {\n      const map = ydoc.getMap(YDOC_KEYS.METADATA);\n      map.set('approvedUsers', [...currentApproved, userId]);\n      map.set('updatedAt', Date.now());\n    },\n    actor ? { actor } : undefined\n  );\n}\n\nexport function revokeUser(ydoc: Y.Doc, userId: string, actor?: string): boolean {\n  const ownerId = getPlanOwnerId(ydoc);\n\n  if (userId === ownerId) {\n    return false;\n  }\n\n  const currentApproved = getApprovedUsers(ydoc);\n  const index = currentApproved.indexOf(userId);\n  if (index === -1) {\n    return false;\n  }\n\n  ydoc.transact(\n    () => {\n      const map = ydoc.getMap(YDOC_KEYS.METADATA);\n      map.set(\n        'approvedUsers',\n        currentApproved.filter((id) => id !== userId)\n      );\n      map.set('updatedAt', Date.now());\n    },\n    actor ? { actor } : undefined\n  );\n\n  return true;\n}\n\nexport function getRejectedUsers(ydoc: Y.Doc): string[] {\n  const map = ydoc.getMap(YDOC_KEYS.METADATA);\n  const rejectedUsers = map.get('rejectedUsers');\n  if (!Array.isArray(rejectedUsers)) {\n    return [];\n  }\n  return rejectedUsers.filter((id): id is string => typeof id === 'string');\n}\n\nexport function isUserRejected(ydoc: Y.Doc, userId: string): boolean {\n  return getRejectedUsers(ydoc).includes(userId);\n}\n\nexport function rejectUser(ydoc: Y.Doc, userId: string, actor?: string): void {\n  const ownerId = getPlanOwnerId(ydoc);\n\n  if (userId === ownerId) {\n    return;\n  }\n\n  const currentRejected = getRejectedUsers(ydoc);\n  const currentApproved = getApprovedUsers(ydoc);\n\n  ydoc.transact(\n    () => {\n      const map = ydoc.getMap(YDOC_KEYS.METADATA);\n\n      if (!currentRejected.includes(userId)) {\n        map.set('rejectedUsers', [...currentRejected, userId]);\n      }\n\n      if (currentApproved.includes(userId)) {\n        map.set(\n          'approvedUsers',\n          currentApproved.filter((id) => id !== userId)\n        );\n      }\n\n      map.set('updatedAt', Date.now());\n    },\n    actor ? { actor } : undefined\n  );\n}\n\nexport function unrejectUser(ydoc: Y.Doc, userId: string, actor?: string): boolean {\n  const currentRejected = getRejectedUsers(ydoc);\n  const index = currentRejected.indexOf(userId);\n  if (index === -1) {\n    return false;\n  }\n\n  ydoc.transact(\n    () => {\n      const map = ydoc.getMap(YDOC_KEYS.METADATA);\n      map.set(\n        'rejectedUsers',\n        currentRejected.filter((id) => id !== userId)\n      );\n      map.set('updatedAt', Date.now());\n    },\n    actor ? { actor } : undefined\n  );\n\n  return true;\n}\n\nexport function getLinkedPRs(ydoc: Y.Doc): LinkedPR[] {\n  const array = ydoc.getArray<LinkedPR>(YDOC_KEYS.LINKED_PRS);\n  const data = array.toJSON() as unknown[];\n\n  return data\n    .map((item) => LinkedPRSchema.safeParse(item))\n    .filter((result) => result.success)\n    .map((result) => result.data);\n}\n\nexport function linkPR(ydoc: Y.Doc, pr: LinkedPR, actor?: string): void {\n  const validated = LinkedPRSchema.parse(pr);\n\n  ydoc.transact(\n    () => {\n      const array = ydoc.getArray<LinkedPR>(YDOC_KEYS.LINKED_PRS);\n      const existing = array.toJSON() as LinkedPR[];\n      const index = existing.findIndex((p) => p.prNumber === validated.prNumber);\n\n      if (index !== -1) {\n        array.delete(index, 1);\n      }\n\n      array.push([validated]);\n    },\n    actor ? { actor } : undefined\n  );\n}\n\nexport function unlinkPR(ydoc: Y.Doc, prNumber: number): boolean {\n  const array = ydoc.getArray<LinkedPR>(YDOC_KEYS.LINKED_PRS);\n  const existing = array.toJSON() as LinkedPR[];\n  const index = existing.findIndex((p) => p.prNumber === prNumber);\n\n  if (index === -1) return false;\n\n  array.delete(index, 1);\n\n  return true;\n}\n\nexport function getLinkedPR(ydoc: Y.Doc, prNumber: number): LinkedPR | null {\n  const prs = getLinkedPRs(ydoc);\n  return prs.find((pr) => pr.prNumber === prNumber) ?? null;\n}\n\nexport function updateLinkedPRStatus(\n  ydoc: Y.Doc,\n  prNumber: number,\n  status: LinkedPR['status']\n): boolean {\n  const array = ydoc.getArray<LinkedPR>(YDOC_KEYS.LINKED_PRS);\n  const existing = array.toJSON() as LinkedPR[];\n  const index = existing.findIndex((p) => p.prNumber === prNumber);\n\n  if (index === -1) return false;\n\n  const pr = existing[index];\n  if (!pr) return false;\n\n  array.delete(index, 1);\n  array.insert(index, [{ ...pr, status }]);\n\n  return true;\n}\n\nexport function getPRReviewComments(ydoc: Y.Doc): PRReviewComment[] {\n  const array = ydoc.getArray<PRReviewComment>(YDOC_KEYS.PR_REVIEW_COMMENTS);\n  const data = array.toJSON() as unknown[];\n\n  return data\n    .map((item) => PRReviewCommentSchema.safeParse(item))\n    .filter((result) => result.success)\n    .map((result) => result.data);\n}\n\nexport function getPRReviewCommentsForPR(ydoc: Y.Doc, prNumber: number): PRReviewComment[] {\n  return getPRReviewComments(ydoc).filter((c) => c.prNumber === prNumber);\n}\n\nexport function addPRReviewComment(ydoc: Y.Doc, comment: PRReviewComment, actor?: string): void {\n  const validated = PRReviewCommentSchema.parse(comment);\n\n  ydoc.transact(\n    () => {\n      const array = ydoc.getArray<PRReviewComment>(YDOC_KEYS.PR_REVIEW_COMMENTS);\n      array.push([validated]);\n    },\n    actor ? { actor } : undefined\n  );\n}\n\nexport function resolvePRReviewComment(ydoc: Y.Doc, commentId: string, resolved: boolean): boolean {\n  const array = ydoc.getArray<PRReviewComment>(YDOC_KEYS.PR_REVIEW_COMMENTS);\n  const existing = array.toJSON() as PRReviewComment[];\n  const index = existing.findIndex((c) => c.id === commentId);\n\n  if (index === -1) return false;\n\n  const comment = existing[index];\n  if (!comment) return false;\n\n  array.delete(index, 1);\n  array.insert(index, [{ ...comment, resolved }]);\n\n  return true;\n}\n\nexport function removePRReviewComment(ydoc: Y.Doc, commentId: string): boolean {\n  const array = ydoc.getArray<PRReviewComment>(YDOC_KEYS.PR_REVIEW_COMMENTS);\n  const existing = array.toJSON() as PRReviewComment[];\n  const index = existing.findIndex((c) => c.id === commentId);\n\n  if (index === -1) return false;\n\n  array.delete(index, 1);\n  return true;\n}\n\nexport function markPlanAsViewed(ydoc: Y.Doc, username: string): void {\n  const map = ydoc.getMap(YDOC_KEYS.METADATA);\n\n  ydoc.transact(() => {\n    const existingViewedBy = map.get('viewedBy');\n    let viewedBy: Record<string, number> = {};\n\n    if (existingViewedBy instanceof Y.Map) {\n      for (const [key, value] of existingViewedBy.entries()) {\n        if (typeof value === 'number') {\n          viewedBy[key] = value;\n        }\n      }\n    } else if (existingViewedBy && typeof existingViewedBy === 'object') {\n      viewedBy = { ...(existingViewedBy as Record<string, number>) };\n    }\n\n    viewedBy[username] = Date.now();\n\n    const viewedByMap = new Y.Map<number>();\n    for (const [user, timestamp] of Object.entries(viewedBy)) {\n      viewedByMap.set(user, timestamp);\n    }\n    map.set('viewedBy', viewedByMap);\n  });\n}\n\nexport function getViewedBy(ydoc: Y.Doc): Record<string, number> {\n  const map = ydoc.getMap(YDOC_KEYS.METADATA);\n  const viewedBy = map.get('viewedBy');\n\n  if (!viewedBy) return {};\n\n  if (viewedBy instanceof Y.Map) {\n    const result: Record<string, number> = {};\n    for (const [key, value] of viewedBy.entries()) {\n      if (typeof value === 'number') {\n        result[key] = value;\n      }\n    }\n    return result;\n  }\n\n  if (typeof viewedBy === 'object') {\n    return viewedBy as Record<string, number>;\n  }\n\n  return {};\n}\n\nexport function isPlanUnread(\n  metadata: Pick<PlanMetadata, 'updatedAt'>,\n  username: string,\n  viewedBy?: Record<string, number>\n): boolean {\n  const viewed = viewedBy ?? {};\n  const lastViewed = viewed[username];\n\n  if (!lastViewed) return true;\n\n  return lastViewed < metadata.updatedAt;\n}\n\nexport function getConversationVersions(ydoc: Y.Doc): ConversationVersion[] {\n  const metadata = getPlanMetadata(ydoc);\n  return metadata?.conversationVersions || [];\n}\n\nexport function addConversationVersion(\n  ydoc: Y.Doc,\n  version: ConversationVersion,\n  actor?: string\n): void {\n  const validated = ConversationVersionSchema.parse(version);\n\n  ydoc.transact(\n    () => {\n      const metadata = ydoc.getMap(YDOC_KEYS.METADATA);\n      const versions = (metadata.get('conversationVersions') as ConversationVersion[]) || [];\n      metadata.set('conversationVersions', [...versions, validated]);\n    },\n    actor ? { actor } : undefined\n  );\n}\n\nexport function markVersionHandedOff(\n  ydoc: Y.Doc,\n  versionId: string,\n  handedOffTo: string,\n  actor?: string\n): void {\n  const versions = getConversationVersions(ydoc);\n  const updated = versions.map((v) => {\n    if (v.versionId !== versionId) return v;\n\n    const handedOffVersion = {\n      ...v,\n      handedOff: true as const,\n      handedOffAt: Date.now(),\n      handedOffTo,\n    };\n\n    return ConversationVersionSchema.parse(handedOffVersion);\n  });\n\n  ydoc.transact(\n    () => {\n      const metadata = ydoc.getMap(YDOC_KEYS.METADATA);\n      metadata.set('conversationVersions', updated);\n    },\n    actor ? { actor } : undefined\n  );\n}\n\n/**\n * Type-safe helper to extract data type for a specific event type.\n * Used to ensure correct data payload for each event type.\n * Handles both required and optional data fields.\n */\ntype EventDataForType<T extends PlanEventType> =\n  Extract<PlanEvent, { type: T }> extends infer E\n    ? E extends { data: infer D }\n      ? D\n      : E extends { data?: infer D }\n        ? D | undefined\n        : undefined\n    : never;\n\n/**\n * Log a plan event with type-safe data payload.\n * TypeScript will enforce that the data parameter matches the event type.\n * @returns The ID of the created event (either provided or generated)\n */\nexport function logPlanEvent<T extends PlanEventType>(\n  ydoc: Y.Doc,\n  type: T,\n  actor: string,\n  ...args: EventDataForType<T> extends undefined\n    ? [\n        data?: undefined,\n        options?: {\n          id?: string;\n          inboxWorthy?: boolean;\n          inboxFor?: string | string[];\n        },\n      ]\n    : [\n        data: EventDataForType<T>,\n        options?: {\n          id?: string;\n          inboxWorthy?: boolean;\n          inboxFor?: string | string[];\n        },\n      ]\n): string {\n  const eventsArray = ydoc.getArray<PlanEvent>(YDOC_KEYS.EVENTS);\n  const [data, options] = args;\n\n  const eventId = options?.id ?? nanoid();\n\n  const baseEvent = {\n    id: eventId,\n    type,\n    actor,\n    timestamp: Date.now(),\n    inboxWorthy: options?.inboxWorthy,\n    inboxFor: options?.inboxFor,\n  };\n\n  const rawEvent = data !== undefined ? { ...baseEvent, data } : baseEvent;\n\n  const parsed = PlanEventSchema.safeParse(rawEvent);\n  if (!parsed.success) {\n    throw new Error(`Invalid plan event: ${parsed.error.message}`);\n  }\n\n  eventsArray.push([parsed.data]);\n  return eventId;\n}\n\nexport function getPlanEvents(ydoc: Y.Doc): PlanEvent[] {\n  const array = ydoc.getArray<PlanEvent>(YDOC_KEYS.EVENTS);\n  const data = array.toJSON() as unknown[];\n\n  return data\n    .map((item) => PlanEventSchema.safeParse(item))\n    .filter((result) => result.success)\n    .map((result) => result.data);\n}\n\n/**\n * Get all snapshots from the Y.Doc.\n * Returns snapshots sorted by createdAt (oldest first).\n */\nexport function getSnapshots(ydoc: Y.Doc): PlanSnapshot[] {\n  const array = ydoc.getArray<PlanSnapshot>(YDOC_KEYS.SNAPSHOTS);\n  const data = array.toJSON() as unknown[];\n\n  return data\n    .map((item) => PlanSnapshotSchema.safeParse(item))\n    .filter((result) => result.success)\n    .map((result) => result.data)\n    .sort((a, b) => a.createdAt - b.createdAt);\n}\n\n/**\n * Add a snapshot to the Y.Doc.\n * Snapshots are append-only for CRDT correctness.\n */\nexport function addSnapshot(ydoc: Y.Doc, snapshot: PlanSnapshot, actor?: string): void {\n  const validated = PlanSnapshotSchema.parse(snapshot);\n\n  ydoc.transact(\n    () => {\n      const array = ydoc.getArray<PlanSnapshot>(YDOC_KEYS.SNAPSHOTS);\n      array.push([validated]);\n    },\n    actor ? { actor } : undefined\n  );\n}\n\n/**\n * Create a snapshot of the current plan state.\n * Captures content, thread summary, artifacts, and deliverables.\n *\n * @param ydoc - The Y.Doc containing the plan\n * @param reason - Why this snapshot was created (e.g., \"Approved by reviewer\")\n * @param actor - Who triggered the snapshot (agent or human name)\n * @param status - The plan status at time of snapshot\n * @param blocks - The content blocks (BlockNote Block[])\n * @returns The created snapshot (not yet added to Y.Doc - call addSnapshot separately)\n */\nexport function createPlanSnapshot(\n  ydoc: Y.Doc,\n  reason: string,\n  actor: string,\n  status: PlanStatusType,\n  blocks: unknown[]\n): PlanSnapshot {\n  const threadsMap = ydoc.getMap<Record<string, unknown>>(YDOC_KEYS.THREADS);\n  const threadsData = threadsMap.toJSON() as Record<string, unknown>;\n  const threads = parseThreads(threadsData);\n  const unresolved = threads.filter((t) => !t.resolved).length;\n\n  const artifacts = getArtifacts(ydoc);\n  const deliverables = getDeliverables(ydoc);\n\n  return {\n    id: nanoid(),\n    status,\n    createdBy: actor,\n    reason,\n    createdAt: Date.now(),\n    content: blocks,\n    threadSummary:\n      threads.length > 0\n        ? {\n            total: threads.length,\n            unresolved,\n          }\n        : undefined,\n    artifacts: artifacts.length > 0 ? artifacts : undefined,\n    deliverables: deliverables.length > 0 ? deliverables : undefined,\n  };\n}\n\n/**\n * Get the latest snapshot from the Y.Doc.\n * Returns null if no snapshots exist.\n */\nexport function getLatestSnapshot(ydoc: Y.Doc): PlanSnapshot | null {\n  const snapshots = getSnapshots(ydoc);\n  if (snapshots.length === 0) return null;\n  return snapshots[snapshots.length - 1] ?? null;\n}\n\n/**\n * Add a tag to a plan (automatically normalizes and deduplicates).\n * Tags are normalized to lowercase and trimmed to prevent duplicates.\n */\nexport function addPlanTag(ydoc: Y.Doc, tag: string, actor?: string): void {\n  ydoc.transact(\n    () => {\n      const map = ydoc.getMap(YDOC_KEYS.METADATA);\n      const currentTags = (map.get('tags') as string[]) || [];\n\n      const normalizedTag = tag.toLowerCase().trim();\n      if (!normalizedTag || currentTags.includes(normalizedTag)) return;\n\n      map.set('tags', [...currentTags, normalizedTag]);\n      map.set('updatedAt', Date.now());\n    },\n    actor ? { actor } : undefined\n  );\n}\n\n/**\n * Remove a tag from a plan.\n */\nexport function removePlanTag(ydoc: Y.Doc, tag: string, actor?: string): void {\n  ydoc.transact(\n    () => {\n      const map = ydoc.getMap(YDOC_KEYS.METADATA);\n      const currentTags = (map.get('tags') as string[]) || [];\n      const normalizedTag = tag.toLowerCase().trim();\n\n      map.set(\n        'tags',\n        currentTags.filter((t) => t !== normalizedTag)\n      );\n      map.set('updatedAt', Date.now());\n    },\n    actor ? { actor } : undefined\n  );\n}\n\n/**\n * Get all unique tags from a list of plan index entries (for autocomplete).\n * Returns sorted array of unique tags.\n */\nexport function getAllTagsFromIndex(indexEntries: Array<{ tags?: string[] }>): string[] {\n  const tagSet = new Set<string>();\n\n  for (const entry of indexEntries) {\n    if (entry.tags) {\n      for (const tag of entry.tags) {\n        tagSet.add(tag);\n      }\n    }\n  }\n\n  return Array.from(tagSet).sort();\n}\n\n/**\n * Result type for archive operations.\n */\nexport type ArchiveResult = { success: true } | { success: false; error: string };\n\n/**\n * Archive a plan - marks it as archived with timestamp and actor.\n * Validates that the plan exists and is not already archived.\n */\nexport function archivePlan(ydoc: Y.Doc, actorId: string): ArchiveResult {\n  const metadata = getPlanMetadata(ydoc);\n  if (!metadata) {\n    return { success: false, error: 'Plan metadata not found' };\n  }\n\n  if (metadata.archivedAt) {\n    return { success: false, error: 'Plan is already archived' };\n  }\n\n  ydoc.transact(\n    () => {\n      const metadataMap = ydoc.getMap(YDOC_KEYS.METADATA);\n      metadataMap.set('archivedAt', Date.now());\n      metadataMap.set('archivedBy', actorId);\n      metadataMap.set('updatedAt', Date.now());\n    },\n    { actor: actorId }\n  );\n\n  return { success: true };\n}\n\n/**\n * Unarchive a plan - removes archived status.\n * Validates that the plan exists and is currently archived.\n */\nexport function unarchivePlan(ydoc: Y.Doc, actorId: string): ArchiveResult {\n  const metadata = getPlanMetadata(ydoc);\n  if (!metadata) {\n    return { success: false, error: 'Plan metadata not found' };\n  }\n\n  if (!metadata.archivedAt) {\n    return { success: false, error: 'Plan is not archived' };\n  }\n\n  ydoc.transact(\n    () => {\n      const metadataMap = ydoc.getMap(YDOC_KEYS.METADATA);\n      metadataMap.delete('archivedAt');\n      metadataMap.delete('archivedBy');\n      metadataMap.set('updatedAt', Date.now());\n    },\n    { actor: actorId }\n  );\n\n  return { success: true };\n}\n\n/**\n * Answer a pending input request with validation.\n * Used by browser UI when user responds to input request modal.\n */\nexport function answerInputRequest(\n  ydoc: Y.Doc,\n  requestId: string,\n  response: string,\n  answeredBy: string\n): { success: boolean; error?: string } {\n  const requestsArray = ydoc.getArray<InputRequest>(YDOC_KEYS.INPUT_REQUESTS);\n  const requests = requestsArray.toJSON() as InputRequest[];\n  const index = requests.findIndex((r) => r.id === requestId);\n\n  if (index === -1) {\n    return { success: false, error: 'Request not found' };\n  }\n\n  const request = requests[index];\n  if (!request) {\n    return { success: false, error: 'Request not found' };\n  }\n\n  if (request.status !== 'pending') {\n    return { success: false, error: `Request is not pending` };\n  }\n\n  const answeredRequest = {\n    ...request,\n    status: 'answered' as const,\n    response,\n    answeredAt: Date.now(),\n    answeredBy,\n  };\n\n  const validated = InputRequestSchema.parse(answeredRequest);\n\n  ydoc.transact(() => {\n    requestsArray.delete(index, 1);\n    requestsArray.insert(index, [validated]);\n  });\n\n  return { success: true };\n}\n\n/**\n * Cancel a pending input request.\n * Used when user closes modal without responding.\n */\nexport function cancelInputRequest(\n  ydoc: Y.Doc,\n  requestId: string\n): { success: boolean; error?: string } {\n  const requestsArray = ydoc.getArray<InputRequest>(YDOC_KEYS.INPUT_REQUESTS);\n  const requests = requestsArray.toJSON() as InputRequest[];\n  const index = requests.findIndex((r) => r.id === requestId);\n\n  if (index === -1) {\n    return { success: false, error: 'Request not found' };\n  }\n\n  const request = requests[index];\n  if (!request) {\n    return { success: false, error: 'Request not found' };\n  }\n\n  if (request.status !== 'pending') {\n    return { success: false, error: `Request is not pending` };\n  }\n\n  const cancelledRequest = {\n    ...request,\n    status: 'cancelled' as const,\n  };\n\n  const validated = InputRequestSchema.parse(cancelledRequest);\n\n  ydoc.transact(() => {\n    requestsArray.delete(index, 1);\n    requestsArray.insert(index, [validated]);\n  });\n\n  return { success: true };\n}\n"],"mappings":"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"}